local moduleScript = Instance.new("ModuleScript")
moduleScript.Name = "PolarisNav"
moduleScript.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\n\n\nlocal api = {}\n\n\n\nfunction api.load_mesh(folder)\n	-- Read mesh from save\n	api:load 'mesh_load'\n	local mesh = api.Mesh.load_dir(folder)\n\n	-- Save line information in points\n	-- Allows line of sight queries\n	api:load 'mesh_line_of_sight'\n	mesh:cache_lines()\n\n	-- Load surfaces into the octree\n	-- Allows finding the ground\n	mesh:load_surfaces()\n\n	return mesh\nend\n\nlocal mesh_cache = setmetatable({}, {\n	__mode = 'v'\n})\nfunction api.agent(model, mesh)\n	local loaded = mesh_cache[mesh]\n	if not loaded then\n		loaded = api.load_mesh(mesh)\n		mesh_cache[mesh] = loaded\n	end\n	return api.Agent(model, loaded)\nend\n\n\nfunction api:load(name)\n	if rawget(api, name) ~= nil then\n		return\n	end\n\n	-- By default, search for the module in the root\n	local module = script:FindFirstChild(name)\n\n		or script.actions:FindFirstChild(name)\n\n	local value\n	if module then\n		value = require(module)\n\n\n	end\n\n\n	api[name] = value\n	return value\nend\n\n\n\n\nfunction api.info(text)\n	print(text)\n\nend\n\nfunction api.warn(text)\n	warn(text)\n\nend\n\nfunction api.error(text)\n	warn(text)\n\nend\n\nreturn setmetatable(api, {__index = api.load})"
local descendantModuleScript1 = Instance.new("ModuleScript", descendantModuleScript0)
descendantModuleScript1.Name = "A"
descendantModuleScript1.Source = "-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nlocal e = require(script.Parent)\n\nlocal GOAL = e.Point.GOAL\nlocal ACTION = e.Point.ACTION\nlocal Queue = e.Queue\n\nlocal A = {}\n\nlocal function new(parent, pt, val, len, action)\n	return {\n		value = val;\n		point = pt;\n		parent = parent;\n		closed = false;\n		length = len;\n		action = action;\n	}\nend\n\nfunction A.find_path(s_ground, g_ground, opts)\n	assert(s_ground.surface, 'The start point has no nav mesh below it')\n	assert(g_ground.surface, 'The goal point has no nav mesh below it')\n\n	-- Find the positions on the surfaces below the start and goal\n	local pos_s = s_ground.surface:project_down(s_ground.point)\n	local pos_g = g_ground.surface:project_down(g_ground.point)\n	local p_goal = e.Point.new(pos_g, GOAL)\n	local goal_record = new(nil, p_goal, math.huge, math.huge)\n\n	-- If points lay on the same surface\n	if s_ground.surface == g_ground.surface then\n		return {goal_record}\n	end\n\n	-- If points have line of sight\n	if s_ground.mesh == g_ground.mesh\n		and s_ground.surface:line_of_sight(pos_s, pos_g)\n	then\n		return {goal_record}\n	end\n\n	-- Initial state\n	local fringe = Queue()\n	local records = { [p_goal] = goal_record }\n	local record, cur_p\n\n	fringe:insert(goal_record)\n\n	local function consider(child_p, value, action)\n		local child = records[child_p]\n		if not child then\n			child = new(record, child_p, value, record.length + 1, action)\n			records[child_p] = child\n			fringe:insert(child)\n			return\n		elseif not child.closed and value < child.value then\n			child.value = value\n			child.parent = record\n			child.length = record.length + 1\n			child.action = action\n			fringe:decrease(child)\n		end\n	end\n\n	-- Begin searching points connected to the start\n	local s_adj = s_ground.mesh:get_visible(s_ground.point, s_ground.surface)\n	for p, cost in next, s_adj do\n		record = new(nil, p, cost, 1)\n		records[p] = record\n		fringe:insert(record)\n	end\n\n	-- Consider the goal when we reach these\n	local finish = g_ground.mesh:get_visible(g_ground.point, g_ground.surface)\n\n	-- The goal is the last record, so we'll hit it and exit.\n	while true do\n		record = fringe:pop()\n\n		-- Check if we've reached the goal\n		if record == goal_record then\n			break\n		end\n\n		record.closed = true\n		local cur_p = record.point\n		local cur_v = record.value\n\n		-- Special case for points connected to goal\n		if finish[cur_p] then\n			consider(p_goal, cur_v + finish[cur_p])\n		end\n\n		-- Go through all visible neighbors\n		for to, cost in next, cur_p.sight do\n			consider(to, cur_v + cost)\n		end\n\n		-- Handle actions associated with this point\n		if cur_p.ptype == ACTION then\n			for s, c_conn in next, cur_p.surfaces do\n				local actions = c_conn:consider(\n					opts.agent, cur_p, cur_v, cur_v)\n				for i, action in ipairs(actions) do\n					consider(action.to, cur_v + action.cost, action)\n				end\n			end\n		end\n	end\n\n	-- No path to goal\n	if goal_record.length == math.huge then\n		return {}\n	end\n\n	local cur = goal_record\n	local path = {}\n	for i = cur.length, 1, -1 do\n		path[i] = cur\n		cur = cur.parent\n	end\n	return path\nend\n\nreturn A"
local descendantModuleScript2 = Instance.new("ModuleScript", descendantModuleScript1)
descendantModuleScript2.Name = "AABB"
descendantModuleScript2.Source = "-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nlocal AABB = {}\nlocal AABB_object = {\n	__index = AABB\n}\nlocal AABB_class = {}\n\nfunction AABB_class:__call(min, max)\n	return setmetatable({\n		min = min;\n		max = max;\n	}, AABB_object)\nend\n\nfunction AABB:support(dir)\n	return Vector3.new(\n		dir.X < 0 and self.min.X or self.max.X,\n		dir.Y < 0 and self.min.Y or self.max.Y,\n		dir.Z < 0 and self.min.Z or self.max.Z\n	)\nend\nfunction AABB:intersection(that)\n	if that.X then\n		return\n			that.X > this.min.X and\n			that.X < this.max.X and\n			that.Y > this.min.Y and\n			that.Y < this.max.Y and\n			that.Z > that.min.Z and\n			that.Z < that.max.Z\n	else\n		return\n			self.min.X < that.max.X and\n			self.max.X > that.min.X and\n			self.min.Y < that.max.Y and\n			self.max.Y > that.min.Y and\n			self.min.Z < that.max.Z and\n			self.max.Z > that.min.Z\n	end\nend\n\nreturn setmetatable(AABB, AABB_class)"
local descendantModuleScript3 = Instance.new("ModuleScript", descendantModuleScript2)
descendantModuleScript3.Name = "Action"
descendantModuleScript3.Source = "return {}
\n"
local descendantModuleScript4 = Instance.new("ModuleScript", descendantModuleScript3)
descendantModuleScript4.Name = "Agent"
descendantModuleScript4.Source = "-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nlocal e = require(script.Parent)\n\nlocal ACTION = e.Point.ACTION\nlocal A = e.A\n\nlocal Agent = {}\nlocal instance_MT = {}\nlocal props = {}\nlocal class_MT = {}\n\nfunction class_MT:__call(model, mesh)\n	local humanoid = model:FindFirstChildOfClass 'Humanoid'\n	assert(humanoid,\n		'NPC model does not have a Humanoid')\n	assert(model:FindFirstChild 'HumanoidRootPart',\n		'NPC model does not have a HumanoidRootPart')\n	local pos = model.HumanoidRootPart.Position\n	return setmetatable({\n		model = model;\n		root = model.HumanoidRootPart;\n		humanoid = humanoid;\n		mesh = mesh;\n		cmd = nil;\n	}, instance_MT)\nend\n\nlocal function to_2d(v)\n	return Vector3.new(v.X, 0, v.Z)\nend\n\nlocal function dist2d(p1, p2)\n	local dx = p1.X - p2.X\n	local dz = p1.Z - p2.Z\n	return math.sqrt(dx * dx + dz * dz)\nend\n\nlocal function dot2d(v1, v2)\n	return v1.X * v2.X + v1.Z * v2.Z\nend\n\nfunction Agent:reached(pos, udir, threshold)\n	return dot2d(udir, self.root.Position - pos) > -threshold\nend\n\nfunction Agent:go(to)\n	local my_ground = self.mesh:get_ground(self.root.Position, 2)\n	if my_ground == nil then\n		warn 'There is no ground under the agent.'\n		return false\n	end\n\n	local to_ground = self.mesh:get_ground(to, 0.1)\n	if to_ground == nil then\n		warn 'There is no ground under the goal.'\n		return false\n	end\n\n	local path = A.find_path(my_ground, to_ground, { agent = self })\n	\n	if #path == 0 then\n		warn 'There is no path to the goal.'\n		return false\n	end\n\n	local cmd = {}\n	self.cmd = cmd\n\n	local last_p = self.root.Position\n	for i, record in ipairs(path) do\n		if self.cmd ~= cmd then\n			break\n		end\n\n		local to = record.point.v3\n		if record.action then\n			record.action:perform(self)\n		else\n			local udir = to_2d(to - last_p).Unit\n			while self.cmd == cmd and not self:reached(to, udir, 0.3) do\n				self.humanoid:Move(to_2d(to - self.root.Position))\n				task.wait()\n			end\n		end\n		last_p = to\n	end\n\n	if self.cmd == cmd then\n		self.humanoid:Move(Vector3.zero)\n		self.cmd = nil\n	end\n\n	return true\nend\n\nfunction instance_MT:__index(key)\n	local v = Agent[key]\n	if v ~= nil then\n		return v\n	end\n\n	v = props[key]\n	if v ~= nil then\n		return v(self)\n	end\nend\n\nreturn setmetatable(Agent, class_MT)"
local descendantModuleScript5 = Instance.new("ModuleScript", descendantModuleScript4)
descendantModuleScript5.Name = "CConnection"
descendantModuleScript5.Source = "-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nreturn {}\n"
local descendantModuleScript6 = Instance.new("ModuleScript", descendantModuleScript5)
descendantModuleScript6.Name = "CFG"
descendantModuleScript6.Source = "-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nlocal use_local = false\nlocal use_dev = false\nlocal use_test = true\nlocal mode = use_dev and 'dev' or use_test and 'test' or 'api'\nlocal url = use_local and 'http://192.168.1.158' or ('https://' .. mode .. '.Polaris-Nav.com')\n\nreturn {\n	DEFAULT_COLOR = Color3.new(0.4, 0.8, 0.4);\n	DEFAULT_TRANS = 0.5;\n\n	SELECTED_COLOR = Color3.new(0.8, 0.4, 0.4);\n	SELECTED_TRANS = 0;\n\n	HOVERED_COLOR = Color3.new(0.4, 0.4, 0.8);\n\n	DEFAULT_CONN_COLOR = Color3.new(0.4, 0.4, 0.8);\n\n	DIST_SAME_VERT = 0.01;\n\n	url = url;\n}"
local descendantModuleScript7 = Instance.new("ModuleScript", descendantModuleScript6)
descendantModuleScript7.Name = "Connection"
descendantModuleScript7.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\n\n\nlocal util = e.util\n\nlocal Connection = {}\nConnection.MT = {\n	__index = Connection\n}\n\nfunction Connection.new(info)\n	return setmetatable(info, Connection.MT)\nend\n\nfunction Connection:get_pts()\n	if not self.pts then\n		local sf = self.fromMesh.surfaces[self.fromID]\n		local st = self.toMesh.surfaces[self.toID]\n		self.pts = {\n			sf:get_p(self.i1, self.t1);\n			st:get_p(self.j1, self.u1);\n			sf:get_p(self.i2, self.t2);\n			st:get_p(self.j2, self.u2);\n		}\n	end\n	return self.pts\nend\n\nreturn Connection"
local descendantModuleScript8 = Instance.new("ModuleScript", descendantModuleScript7)
descendantModuleScript8.Name = "LibDeflate"
descendantModuleScript8.Source = "--[[--\nLibDeflate 1.0.2-release <br>\nPure Lua compressor and decompressor with high compression ratio using\nDEFLATE/zlib format.\n\n@file LibDeflate.lua\n@author Haoqian He (Github: SafeteeWoW; World of Warcraft: Safetyy-Illidan(US))\n@copyright LibDeflate <2018-2021> Haoqian He\n@license zlib License\n\nThis library is implemented according to the following specifications. <br>\nReport a bug if LibDeflate is not fully compliant with those specs. <br>\nBoth compressors and decompressors have been implemented in the library.<br>\n1. RFC1950: DEFLATE Compressed Data Format Specification version 1.3 <br>\nhttps://tools.ietf.org/html/rfc1951 <br>\n2. RFC1951: ZLIB Compressed Data Format Specification version 3.3 <br>\nhttps://tools.ietf.org/html/rfc1950 <br>\n\nThis library requires Lua 5.1/5.2/5.3/5.4 interpreter or LuaJIT v2.0+. <br>\nThis library does not have any dependencies. <br>\n<br>\nThis file \"LibDeflate.lua\" is the only source file of\nthe library. <br>\nSubmit suggestions or report bugs to\nhttps://github.com/safeteeWow/LibDeflate/issues\n]] --[[\nzlib License\n\n(C) 2018-2021 Haoqian He\n\nThis software is provided 'as-is', without any express or implied\nwarranty.  In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must not\n   claim that you wrote the original software. If you use this software\n   in a product, an acknowledgment in the product documentation would be\n   appreciated but is not required.\n2. Altered source versions must be plainly marked as such, and must not be\n   misrepresented as being the original software.\n3. This notice may not be removed or altered from any source distribution.\n\nLicense History:\n1. GNU General Public License Version 3 in v1.0.0 and earlier versions.\n2. GNU Lesser General Public License Version 3 in v1.0.1\n3. the zlib License since v1.0.2\n\nCredits and Disclaimer:\nThis library rewrites the code from the algorithm\nand the ideas of the following projects,\nand uses their code to help to test the correctness of this library,\nbut their code is not included directly in the library itself.\nTheir original licenses shall be comply when used.\n\n1. zlib, by Jean-loup Gailly (compression) and Mark Adler (decompression).\n	http://www.zlib.net/\n	Licensed under zlib License. http://www.zlib.net/zlib_license.html\n	For the compression algorithm.\n2. puff, by Mark Adler. https://github.com/madler/zlib/tree/master/contrib/puff\n	Licensed under zlib License. http://www.zlib.net/zlib_license.html\n	For the decompression algorithm.\n3. LibCompress, by jjsheets and Galmok of European Stormrage (Horde)\n	https://www.wowace.com/projects/libcompress\n	Licensed under GPLv2.\n	https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n	For the code to create customized codec.\n4. WeakAuras2,\n	https://github.com/WeakAuras/WeakAuras2\n	Licensed under GPLv2.\n	For the 6bit encoding and decoding.\n]] --[[\n	Curseforge auto-packaging replacements:\n\n	Project Date: @project-date-iso@\n	Project Hash: @project-hash@\n	Project Version: @project-version@\n--]] local LibDeflate\n\ndo\n  -- Semantic version. all lowercase.\n  -- Suffix can be alpha1, alpha2, beta1, beta2, rc1, rc2, etc.\n  -- NOTE: Two version numbers needs to modify.\n  -- 1. On the top of LibDeflate.lua\n  -- 2. _VERSION\n  -- 3. _MINOR\n\n  -- version to store the official version of LibDeflate\n  local _VERSION = \"1.0.2-release\"\n\n  -- When MAJOR is changed, I should name it as LibDeflate2\n  local _MAJOR = \"LibDeflate\"\n\n  -- Update this whenever a new version, for LibStub version registration.\n  -- 0 : v0.x\n  -- 1 : v1.0.0\n  -- 2 : v1.0.1\n  -- 3 : v1.0.2\n  local _MINOR = 3\n\n  local _COPYRIGHT = \"LibDeflate \" .. _VERSION ..\n                       \" Copyright (C) 2018-2021 Haoqian He.\" ..\n                       \" Licensed under the zlib License\"\n\n  -- Register in the World of Warcraft library \"LibStub\" if detected.\n  if LibStub then\n    local lib, minor = LibStub:GetLibrary(_MAJOR, true)\n    if lib and minor and minor >= _MINOR then -- No need to update.\n      return lib\n    else -- Update or first time register\n      LibDeflate = LibStub:NewLibrary(_MAJOR, _MINOR)\n      -- NOTE: It is important that new version has implemented\n      -- all exported APIs and tables in the old version,\n      -- so the old library is fully garbage collected,\n      -- and we 100% ensure the backward compatibility.\n    end\n  else -- \"LibStub\" is not detected.\n    LibDeflate = {}\n  end\n\n  LibDeflate._VERSION = _VERSION\n  LibDeflate._MAJOR = _MAJOR\n  LibDeflate._MINOR = _MINOR\n  LibDeflate._COPYRIGHT = _COPYRIGHT\nend\n\n-- localize Lua api for faster access.\nlocal assert = assert\nlocal error = error\nlocal pairs = pairs\nlocal string_byte = string.byte\nlocal string_char = string.char\nlocal string_find = string.find\nlocal string_gsub = string.gsub\nlocal string_sub = string.sub\nlocal table_concat = table.concat\nlocal table_sort = table.sort\nlocal tostring = tostring\nlocal type = type\n\n-- Converts i to 2^i, (0<=i<=32)\n-- This is used to implement bit left shift and bit right shift.\n-- \"x >> y\" in C:   \"(x-x%_pow2[y])/_pow2[y]\" in Lua\n-- \"x << y\" in C:   \"x*_pow2[y]\" in Lua\nlocal _pow2 = {}\n\n-- Converts any byte to a character, (0<=byte<=255)\nlocal _byte_to_char = {}\n\n-- _reverseBitsTbl[len][val] stores the bit reverse of\n-- the number with bit length \"len\" and value \"val\"\n-- For example, decimal number 6 with bits length 5 is binary 00110\n-- It's reverse is binary 01100,\n-- which is decimal 12 and 12 == _reverseBitsTbl[5][6]\n-- 1<=len<=9, 0<=val<=2^len-1\n-- The reason for 1<=len<=9 is that the max of min bitlen of huffman code\n-- of a huffman alphabet is 9?\nlocal _reverse_bits_tbl = {}\n\n-- Convert a LZ77 length (3<=len<=258) to\n-- a deflate literal/LZ77_length code (257<=code<=285)\nlocal _length_to_deflate_code = {}\n\n-- convert a LZ77 length (3<=len<=258) to\n-- a deflate literal/LZ77_length code extra bits.\nlocal _length_to_deflate_extra_bits = {}\n\n-- Convert a LZ77 length (3<=len<=258) to\n-- a deflate literal/LZ77_length code extra bit length.\nlocal _length_to_deflate_extra_bitlen = {}\n\n-- Convert a small LZ77 distance (1<=dist<=256) to a deflate code.\nlocal _dist256_to_deflate_code = {}\n\n-- Convert a small LZ77 distance (1<=dist<=256) to\n-- a deflate distance code extra bits.\nlocal _dist256_to_deflate_extra_bits = {}\n\n-- Convert a small LZ77 distance (1<=dist<=256) to\n-- a deflate distance code extra bit length.\nlocal _dist256_to_deflate_extra_bitlen = {}\n\n-- Convert a literal/LZ77_length deflate code to LZ77 base length\n-- The key of the table is (code - 256), 257<=code<=285\nlocal _literal_deflate_code_to_base_len =\n  {\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67,\n    83, 99, 115, 131, 163, 195, 227, 258\n  }\n\n-- Convert a literal/LZ77_length deflate code to base LZ77 length extra bits\n-- The key of the table is (code - 256), 257<=code<=285\nlocal _literal_deflate_code_to_extra_bitlen =\n  {\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,\n    5, 5, 5, 0\n  }\n\n-- Convert a distance deflate code to base LZ77 distance. (0<=code<=29)\nlocal _dist_deflate_code_to_base_dist = {\n  [0] = 1,\n  2,\n  3,\n  4,\n  5,\n  7,\n  9,\n  13,\n  17,\n  25,\n  33,\n  49,\n  65,\n  97,\n  129,\n  193,\n  257,\n  385,\n  513,\n  769,\n  1025,\n  1537,\n  2049,\n  3073,\n  4097,\n  6145,\n  8193,\n  12289,\n  16385,\n  24577\n}\n\n-- Convert a distance deflate code to LZ77 bits length. (0<=code<=29)\nlocal _dist_deflate_code_to_extra_bitlen =\n  {\n    [0] = 0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13\n  }\n\n-- The code order of the first huffman header in the dynamic deflate block.\n-- See the page 12 of RFC1951\nlocal _rle_codes_huffman_bitlen_order = {\n  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15\n}\n\n-- The following tables are used by fixed deflate block.\n-- The value of these tables are assigned at the bottom of the source.\n\n-- The huffman code of the literal/LZ77_length deflate codes,\n-- in fixed deflate block.\nlocal _fix_block_literal_huffman_code\n\n-- Convert huffman code of the literal/LZ77_length to deflate codes,\n-- in fixed deflate block.\nlocal _fix_block_literal_huffman_to_deflate_code\n\n-- The bit length of the huffman code of literal/LZ77_length deflate codes,\n-- in fixed deflate block.\nlocal _fix_block_literal_huffman_bitlen\n\n-- The count of each bit length of the literal/LZ77_length deflate codes,\n-- in fixed deflate block.\nlocal _fix_block_literal_huffman_bitlen_count\n\n-- The huffman code of the distance deflate codes,\n-- in fixed deflate block.\nlocal _fix_block_dist_huffman_code\n\n-- Convert huffman code of the distance to deflate codes,\n-- in fixed deflate block.\nlocal _fix_block_dist_huffman_to_deflate_code\n\n-- The bit length of the huffman code of the distance deflate codes,\n-- in fixed deflate block.\nlocal _fix_block_dist_huffman_bitlen\n\n-- The count of each bit length of the huffman code of\n-- the distance deflate codes,\n-- in fixed deflate block.\nlocal _fix_block_dist_huffman_bitlen_count\n\nfor i = 0, 255 do _byte_to_char[i] = string_char(i) end\n\ndo\n  local pow = 1\n  for i = 0, 32 do\n    _pow2[i] = pow\n    pow = pow * 2\n  end\nend\n\nfor i = 1, 9 do\n  _reverse_bits_tbl[i] = {}\n  for j = 0, _pow2[i + 1] - 1 do\n    local reverse = 0\n    local value = j\n    for _ = 1, i do\n      -- The following line is equivalent to \"res | (code %2)\" in C.\n      reverse = reverse - reverse % 2 +\n                  (((reverse % 2 == 1) or (value % 2) == 1) and 1 or 0)\n      value = (value - value % 2) / 2\n      reverse = reverse * 2\n    end\n    _reverse_bits_tbl[i][j] = (reverse - reverse % 2) / 2\n  end\nend\n\n-- The source code is written according to the pattern in the numbers\n-- in RFC1951 Page10.\ndo\n  local a = 18\n  local b = 16\n  local c = 265\n  local bitlen = 1\n  for len = 3, 258 do\n    if len <= 10 then\n      _length_to_deflate_code[len] = len + 254\n      _length_to_deflate_extra_bitlen[len] = 0\n    elseif len == 258 then\n      _length_to_deflate_code[len] = 285\n      _length_to_deflate_extra_bitlen[len] = 0\n    else\n      if len > a then\n        a = a + b\n        b = b * 2\n        c = c + 4\n        bitlen = bitlen + 1\n      end\n      local t = len - a - 1 + b / 2\n      _length_to_deflate_code[len] = (t - (t % (b / 8))) / (b / 8) + c\n      _length_to_deflate_extra_bitlen[len] = bitlen\n      _length_to_deflate_extra_bits[len] = t % (b / 8)\n    end\n  end\nend\n\n-- The source code is written according to the pattern in the numbers\n-- in RFC1951 Page11.\ndo\n  _dist256_to_deflate_code[1] = 0\n  _dist256_to_deflate_code[2] = 1\n  _dist256_to_deflate_extra_bitlen[1] = 0\n  _dist256_to_deflate_extra_bitlen[2] = 0\n\n  local a = 3\n  local b = 4\n  local code = 2\n  local bitlen = 0\n  for dist = 3, 256 do\n    if dist > b then\n      a = a * 2\n      b = b * 2\n      code = code + 2\n      bitlen = bitlen + 1\n    end\n    _dist256_to_deflate_code[dist] = (dist <= a) and code or (code + 1)\n    _dist256_to_deflate_extra_bitlen[dist] = (bitlen < 0) and 0 or bitlen\n    if b >= 8 then\n      _dist256_to_deflate_extra_bits[dist] = (dist - b / 2 - 1) % (b / 4)\n    end\n  end\nend\n\n--- Calculate the Adler-32 checksum of the string. <br>\n-- See RFC1950 Page 9 https://tools.ietf.org/html/rfc1950 for the\n-- definition of Adler-32 checksum.\n-- @param str [string] the input string to calcuate its Adler-32 checksum.\n-- @return [integer] The Adler-32 checksum, which is greater or equal to 0,\n-- and less than 2^32 (4294967296).\nfunction LibDeflate:Adler32(str)\n  -- This function is loop unrolled by better performance.\n  --\n  -- Here is the minimum code:\n  --\n  -- local a = 1\n  -- local b = 0\n  -- for i=1, #str do\n  -- 		local s = string.byte(str, i, i)\n  -- 		a = (a+s)%65521\n  -- 		b = (b+a)%65521\n  -- 		end\n  -- return b*65536+a\n  if type(str) ~= \"string\" then\n    error((\"Usage: LibDeflate:Adler32(str):\" ..\n            \" 'str' - string expected got '%s'.\"):format(type(str)), 2)\n  end\n  local strlen = #str\n\n  local i = 1\n  local a = 1\n  local b = 0\n  while i <= strlen - 15 do\n    local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16 =\n      string_byte(str, i, i + 15)\n    b =\n      (b + 16 * a + 16 * x1 + 15 * x2 + 14 * x3 + 13 * x4 + 12 * x5 + 11 * x6 +\n        10 * x7 + 9 * x8 + 8 * x9 + 7 * x10 + 6 * x11 + 5 * x12 + 4 * x13 + 3 *\n        x14 + 2 * x15 + x16) % 65521\n    a =\n      (a + x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 + x12 + x13 +\n        x14 + x15 + x16) % 65521\n    i = i + 16\n  end\n  while (i <= strlen) do\n    local x = string_byte(str, i, i)\n    a = (a + x) % 65521\n    b = (b + a) % 65521\n    i = i + 1\n  end\n  return (b * 65536 + a) % 4294967296\nend\n\n-- Compare adler32 checksum.\n-- adler32 should be compared with a mod to avoid sign problem\n-- 4072834167 (unsigned) is the same adler32 as -222133129\nlocal function IsEqualAdler32(actual, expected)\n  return (actual % 4294967296) == (expected % 4294967296)\nend\n\n--- Create a preset dictionary.\n--\n-- This function is not fast, and the memory consumption of the produced\n-- dictionary is about 50 times of the input string. Therefore, it is suggestted\n-- to run this function only once in your program.\n--\n-- It is very important to know that if you do use a preset dictionary,\n-- compressors and decompressors MUST USE THE SAME dictionary. That is,\n-- dictionary must be created using the same string. If you update your program\n-- with a new dictionary, people with the old version won't be able to transmit\n-- data with people with the new version. Therefore, changing the dictionary\n-- must be very careful.\n--\n-- The parameters \"strlen\" and \"adler32\" add a layer of verification to ensure\n-- the parameter \"str\" is not modified unintentionally during the program\n-- development.\n--\n-- @usage local dict_str = \"1234567890\"\n--\n-- -- print(dict_str:len(), LibDeflate:Adler32(dict_str))\n-- -- Hardcode the print result below to verify it to avoid acciently\n-- -- modification of 'str' during the program development.\n-- -- string length: 10, Adler-32: 187433486,\n-- -- Don't calculate string length and its Adler-32 at run-time.\n--\n-- local dict = LibDeflate:CreateDictionary(dict_str, 10, 187433486)\n--\n-- @param str [string] The string used as the preset dictionary. <br>\n-- You should put stuffs that frequently appears in the dictionary\n-- string and preferablely put more frequently appeared stuffs toward the end\n-- of the string. <br>\n-- Empty string and string longer than 32768 bytes are not allowed.\n-- @param strlen [integer] The length of 'str'. Please pass in this parameter\n-- as a hardcoded constant, in order to verify the content of 'str'. The value\n-- of this parameter should be known before your program runs.\n-- @param adler32 [integer] The Adler-32 checksum of 'str'. Please pass in this\n-- parameter as a hardcoded constant, in order to verify the content of 'str'.\n-- The value of this parameter should be known before your program runs.\n-- @return  [table] The dictionary used for preset dictionary compression and\n-- decompression.\n-- @raise error if 'strlen' does not match the length of 'str',\n-- or if 'adler32' does not match the Adler-32 checksum of 'str'.\nfunction LibDeflate:CreateDictionary(str, strlen, adler32)\n  if type(str) ~= \"string\" then\n    error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\" ..\n            \" 'str' - string expected got '%s'.\"):format(type(str)), 2)\n  end\n  if type(strlen) ~= \"number\" then\n    error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\" ..\n            \" 'strlen' - number expected got '%s'.\"):format(type(strlen)), 2)\n  end\n  if type(adler32) ~= \"number\" then\n    error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\" ..\n            \" 'adler32' - number expected got '%s'.\"):format(type(adler32)), 2)\n  end\n  if strlen ~= #str then\n    error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\" ..\n            \" 'strlen' does not match the actual length of 'str'.\" ..\n            \" 'strlen': %u, '#str': %u .\" ..\n            \" Please check if 'str' is modified unintentionally.\"):format(\n            strlen, #str))\n  end\n  if strlen == 0 then\n    error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\" ..\n            \" 'str' - Empty string is not allowed.\"), 2)\n  end\n  if strlen > 32768 then\n    error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\" ..\n            \" 'str' - string longer than 32768 bytes is not allowed.\" ..\n            \" Got %d bytes.\"):format(strlen), 2)\n  end\n  local actual_adler32 = self:Adler32(str)\n  if not IsEqualAdler32(adler32, actual_adler32) then\n    error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\" ..\n            \" 'adler32' does not match the actual adler32 of 'str'.\" ..\n            \" 'adler32': %u, 'Adler32(str)': %u .\" ..\n            \" Please check if 'str' is modified unintentionally.\"):format(\n            adler32, actual_adler32))\n  end\n\n  local dictionary = {}\n  dictionary.adler32 = adler32\n  dictionary.hash_tables = {}\n  dictionary.string_table = {}\n  dictionary.strlen = strlen\n  local string_table = dictionary.string_table\n  local hash_tables = dictionary.hash_tables\n  string_table[1] = string_byte(str, 1, 1)\n  string_table[2] = string_byte(str, 2, 2)\n  if strlen >= 3 then\n    local i = 1\n    local hash = string_table[1] * 256 + string_table[2]\n    while i <= strlen - 2 - 3 do\n      local x1, x2, x3, x4 = string_byte(str, i + 2, i + 5)\n      string_table[i + 2] = x1\n      string_table[i + 3] = x2\n      string_table[i + 4] = x3\n      string_table[i + 5] = x4\n      hash = (hash * 256 + x1) % 16777216\n      local t = hash_tables[hash]\n      if not t then\n        t = {};\n        hash_tables[hash] = t\n      end\n      t[#t + 1] = i - strlen\n      i = i + 1\n      hash = (hash * 256 + x2) % 16777216\n      t = hash_tables[hash]\n      if not t then\n        t = {};\n        hash_tables[hash] = t\n      end\n      t[#t + 1] = i - strlen\n      i = i + 1\n      hash = (hash * 256 + x3) % 16777216\n      t = hash_tables[hash]\n      if not t then\n        t = {};\n        hash_tables[hash] = t\n      end\n      t[#t + 1] = i - strlen\n      i = i + 1\n      hash = (hash * 256 + x4) % 16777216\n      t = hash_tables[hash]\n      if not t then\n        t = {};\n        hash_tables[hash] = t\n      end\n      t[#t + 1] = i - strlen\n      i = i + 1\n    end\n    while i <= strlen - 2 do\n      local x = string_byte(str, i + 2)\n      string_table[i + 2] = x\n      hash = (hash * 256 + x) % 16777216\n      local t = hash_tables[hash]\n      if not t then\n        t = {};\n        hash_tables[hash] = t\n      end\n      t[#t + 1] = i - strlen\n      i = i + 1\n    end\n  end\n  return dictionary\nend\n\n-- Check if the dictionary is valid.\n-- @param dictionary The preset dictionary for compression and decompression.\n-- @return true if valid, false if not valid.\n-- @return if not valid, the error message.\nlocal function IsValidDictionary(dictionary)\n  if type(dictionary) ~= \"table\" then\n    return false,\n           (\"'dictionary' - table expected got '%s'.\"):format(type(dictionary))\n  end\n  if type(dictionary.adler32) ~= \"number\" or type(dictionary.string_table) ~=\n    \"table\" or type(dictionary.strlen) ~= \"number\" or dictionary.strlen <= 0 or\n    dictionary.strlen > 32768 or dictionary.strlen ~= #dictionary.string_table or\n    type(dictionary.hash_tables) ~= \"table\" then\n    return false,\n           (\"'dictionary' - corrupted dictionary.\"):format(type(dictionary))\n  end\n  return true, \"\"\nend\n\n--[[\n	key of the configuration table is the compression level,\n	and its value stores the compression setting.\n	These numbers come from zlib source code.\n\n	Higher compression level usually means better compression.\n	(Because LibDeflate uses a simplified version of zlib algorithm,\n	there is no guarantee that higher compression level does not create\n	bigger file than lower level, but I can say it's 99% likely)\n\n	Be careful with the high compression level. This is a pure lua\n	implementation compressor/decompressor, which is significant slower than\n	a C/C++ equivalant compressor/decompressor. Very high compression level\n	costs significant more CPU time, and usually compression size won't be\n	significant smaller when you increase compression level by 1, when the\n	level is already very high. Benchmark yourself if you can afford it.\n\n	See also https://github.com/madler/zlib/blob/master/doc/algorithm.txt,\n	https://github.com/madler/zlib/blob/master/deflate.c for more information.\n\n	The meaning of each field:\n	@field 1 use_lazy_evaluation:\n		true/false. Whether the program uses lazy evaluation.\n		See what is \"lazy evaluation\" in the link above.\n		lazy_evaluation improves ratio, but relatively slow.\n	@field 2 good_prev_length:\n		Only effective if lazy is set, Only use 1/4 of max_chain,\n		if prev length of lazy match is above this.\n	@field 3 max_insert_length/max_lazy_match:\n		If not using lazy evaluation,\n		insert new strings in the hash table only if the match length is not\n		greater than this length.\n		If using lazy evaluation, only continue lazy evaluation,\n		if previous match length is strictly smaller than this value.\n	@field 4 nice_length:\n		Number. Don't continue to go down the hash chain,\n		if match length is above this.\n	@field 5 max_chain:\n		Number. The maximum number of hash chains we look.\n--]]\nlocal _compression_level_configs = {\n  [0] = {false, nil, 0, 0, 0}, -- level 0, no compression\n  [1] = {false, nil, 4, 8, 4}, -- level 1, similar to zlib level 1\n  [2] = {false, nil, 5, 18, 8}, -- level 2, similar to zlib level 2\n  [3] = {false, nil, 6, 32, 32}, -- level 3, similar to zlib level 3\n  [4] = {true, 4, 4, 16, 16}, -- level 4, similar to zlib level 4\n  [5] = {true, 8, 16, 32, 32}, -- level 5, similar to zlib level 5\n  [6] = {true, 8, 16, 128, 128}, -- level 6, similar to zlib level 6\n  [7] = {true, 8, 32, 128, 256}, -- (SLOW) level 7, similar to zlib level 7\n  [8] = {true, 32, 128, 258, 1024}, -- (SLOW) level 8,similar to zlib level 8\n  [9] = {true, 32, 258, 258, 4096}\n  -- (VERY SLOW) level 9, similar to zlib level 9\n}\n\n-- Check if the compression/decompression arguments is valid\n-- @param str The input string.\n-- @param check_dictionary if true, check if dictionary is valid.\n-- @param dictionary The preset dictionary for compression and decompression.\n-- @param check_configs if true, check if config is valid.\n-- @param configs The compression configuration table\n-- @return true if valid, false if not valid.\n-- @return if not valid, the error message.\nlocal function IsValidArguments(str, check_dictionary, dictionary,\n                                check_configs, configs)\n\n  if type(str) ~= \"string\" then\n    return false, (\"'str' - string expected got '%s'.\"):format(type(str))\n  end\n  if check_dictionary then\n    local dict_valid, dict_err = IsValidDictionary(dictionary)\n    if not dict_valid then return false, dict_err end\n  end\n  if check_configs then\n    local type_configs = type(configs)\n    if type_configs ~= \"nil\" and type_configs ~= \"table\" then\n      return false, (\"'configs' - nil or table expected got '%s'.\"):format(\n               type(configs))\n    end\n    if type_configs == \"table\" then\n      for k, v in pairs(configs) do\n        if k ~= \"level\" and k ~= \"strategy\" then\n          return false,\n                 (\"'configs' - unsupported table key in the configs: '%s'.\"):format(\n                   k)\n        elseif k == \"level\" and not _compression_level_configs[v] then\n          return false,\n                 (\"'configs' - unsupported 'level': %s.\"):format(tostring(v))\n        elseif k == \"strategy\" and v ~= \"fixed\" and v ~= \"huffman_only\" and v ~=\n          \"dynamic\" then\n          -- random_block_type is for testing purpose\n          return false, (\"'configs' - unsupported 'strategy': '%s'.\"):format(\n                   tostring(v))\n        end\n      end\n    end\n  end\n  return true, \"\"\nend\n\n--[[ --------------------------------------------------------------------------\n	Compress code\n--]] --------------------------------------------------------------------------\n\n-- partial flush to save memory\nlocal _FLUSH_MODE_MEMORY_CLEANUP = 0\n-- full flush with partial bytes\nlocal _FLUSH_MODE_OUTPUT = 1\n-- write bytes to get to byte boundary\nlocal _FLUSH_MODE_BYTE_BOUNDARY = 2\n-- no flush, just get num of bits written so far\nlocal _FLUSH_MODE_NO_FLUSH = 3\n\n--[[\n	Create an empty writer to easily write stuffs as the unit of bits.\n	Return values:\n	1. WriteBits(code, bitlen):\n	2. WriteString(str):\n	3. Flush(mode):\n--]]\nlocal function CreateWriter()\n  local buffer_size = 0\n  local cache = 0\n  local cache_bitlen = 0\n  local total_bitlen = 0\n  local buffer = {}\n  -- When buffer is big enough, flush into result_buffer to save memory.\n  local result_buffer = {}\n\n  -- Write bits with value \"value\" and bit length of \"bitlen\" into writer.\n  -- @param value: The value being written\n  -- @param bitlen: The bit length of \"value\"\n  -- @return nil\n  local function WriteBits(value, bitlen)\n    cache = cache + value * _pow2[cache_bitlen]\n    cache_bitlen = cache_bitlen + bitlen\n    total_bitlen = total_bitlen + bitlen\n    -- Only bulk to buffer every 4 bytes. This is quicker.\n    if cache_bitlen >= 32 then\n      buffer_size = buffer_size + 1\n      buffer[buffer_size] = _byte_to_char[cache % 256] ..\n                              _byte_to_char[((cache - cache % 256) / 256 % 256)] ..\n                              _byte_to_char[((cache - cache % 65536) / 65536 %\n                                256)] ..\n                              _byte_to_char[((cache - cache % 16777216) /\n                                16777216 % 256)]\n      local rshift_mask = _pow2[32 - cache_bitlen + bitlen]\n      cache = (value - value % rshift_mask) / rshift_mask\n      cache_bitlen = cache_bitlen - 32\n    end\n  end\n\n  -- Write the entire string into the writer.\n  -- @param str The string being written\n  -- @return nil\n  local function WriteString(str)\n    for _ = 1, cache_bitlen, 8 do\n      buffer_size = buffer_size + 1\n      buffer[buffer_size] = string_char(cache % 256)\n      cache = (cache - cache % 256) / 256\n    end\n    cache_bitlen = 0\n    buffer_size = buffer_size + 1\n    buffer[buffer_size] = str\n    total_bitlen = total_bitlen + #str * 8\n  end\n\n  -- Flush current stuffs in the writer and return it.\n  -- This operation will free most of the memory.\n  -- @param mode See the descrtion of the constant and the source code.\n  -- @return The total number of bits stored in the writer right now.\n  -- for byte boundary mode, it includes the padding bits.\n  -- for output mode, it does not include padding bits.\n  -- @return Return the outputs if mode is output.\n  local function FlushWriter(mode)\n    if mode == _FLUSH_MODE_NO_FLUSH then return total_bitlen end\n\n    if mode == _FLUSH_MODE_OUTPUT or mode == _FLUSH_MODE_BYTE_BOUNDARY then\n      -- Full flush, also output cache.\n      -- Need to pad some bits if cache_bitlen is not multiple of 8.\n      local padding_bitlen = (8 - cache_bitlen % 8) % 8\n\n      if cache_bitlen > 0 then\n        -- padding with all 1 bits, mainly because \"\000\" is not\n        -- good to be tranmitted. I do this so \"\000\" is a little bit\n        -- less frequent.\n        cache = cache - _pow2[cache_bitlen] +\n                  _pow2[cache_bitlen + padding_bitlen]\n        for _ = 1, cache_bitlen, 8 do\n          buffer_size = buffer_size + 1\n          buffer[buffer_size] = _byte_to_char[cache % 256]\n          cache = (cache - cache % 256) / 256\n        end\n\n        cache = 0\n        cache_bitlen = 0\n      end\n      if mode == _FLUSH_MODE_BYTE_BOUNDARY then\n        total_bitlen = total_bitlen + padding_bitlen\n        return total_bitlen\n      end\n    end\n\n    local flushed = table_concat(buffer)\n    buffer = {}\n    buffer_size = 0\n    result_buffer[#result_buffer + 1] = flushed\n\n    if mode == _FLUSH_MODE_MEMORY_CLEANUP then\n      return total_bitlen\n    else\n      return total_bitlen, table_concat(result_buffer)\n    end\n  end\n\n  return WriteBits, WriteString, FlushWriter\nend\n\n-- Push an element into a max heap\n-- @param heap A max heap whose max element is at index 1.\n-- @param e The element to be pushed. Assume element \"e\" is a table\n--  and comparison is done via its first entry e[1]\n-- @param heap_size current number of elements in the heap.\n--  NOTE: There may be some garbage stored in\n--  heap[heap_size+1], heap[heap_size+2], etc..\n-- @return nil\nlocal function MinHeapPush(heap, e, heap_size)\n  heap_size = heap_size + 1\n  heap[heap_size] = e\n  local value = e[1]\n  local pos = heap_size\n  local parent_pos = (pos - pos % 2) / 2\n\n  while (parent_pos >= 1 and heap[parent_pos][1] > value) do\n    local t = heap[parent_pos]\n    heap[parent_pos] = e\n    heap[pos] = t\n    pos = parent_pos\n    parent_pos = (parent_pos - parent_pos % 2) / 2\n  end\nend\n\n-- Pop an element from a max heap\n-- @param heap A max heap whose max element is at index 1.\n-- @param heap_size current number of elements in the heap.\n-- @return the poped element\n-- Note: This function does not change table size of \"heap\" to save CPU time.\nlocal function MinHeapPop(heap, heap_size)\n  local top = heap[1]\n  local e = heap[heap_size]\n  local value = e[1]\n  heap[1] = e\n  heap[heap_size] = top\n  heap_size = heap_size - 1\n\n  local pos = 1\n  local left_child_pos = pos * 2\n  local right_child_pos = left_child_pos + 1\n\n  while (left_child_pos <= heap_size) do\n    local left_child = heap[left_child_pos]\n    if (right_child_pos <= heap_size and heap[right_child_pos][1] <\n      left_child[1]) then\n      local right_child = heap[right_child_pos]\n      if right_child[1] < value then\n        heap[right_child_pos] = e\n        heap[pos] = right_child\n        pos = right_child_pos\n        left_child_pos = pos * 2\n        right_child_pos = left_child_pos + 1\n      else\n        break\n      end\n    else\n      if left_child[1] < value then\n        heap[left_child_pos] = e\n        heap[pos] = left_child\n        pos = left_child_pos\n        left_child_pos = pos * 2\n        right_child_pos = left_child_pos + 1\n      else\n        break\n      end\n    end\n  end\n\n  return top\nend\n\n-- Deflate defines a special huffman tree, which is unique once the bit length\n-- of huffman code of all symbols are known.\n-- @param bitlen_count Number of symbols with a specific bitlen\n-- @param symbol_bitlen The bit length of a symbol\n-- @param max_symbol The max symbol among all symbols,\n--		which is (number of symbols - 1)\n-- @param max_bitlen The max huffman bit length among all symbols.\n-- @return The huffman code of all symbols.\nlocal function GetHuffmanCodeFromBitlen(bitlen_counts, symbol_bitlens,\n                                        max_symbol, max_bitlen)\n  local huffman_code = 0\n  local next_codes = {}\n  local symbol_huffman_codes = {}\n  for bitlen = 1, max_bitlen do\n    huffman_code = (huffman_code + (bitlen_counts[bitlen - 1] or 0)) * 2\n    next_codes[bitlen] = huffman_code\n  end\n  for symbol = 0, max_symbol do\n    local bitlen = symbol_bitlens[symbol]\n    if bitlen then\n      huffman_code = next_codes[bitlen]\n      next_codes[bitlen] = huffman_code + 1\n\n      -- Reverse the bits of huffman code,\n      -- because most signifant bits of huffman code\n      -- is stored first into the compressed data.\n      -- @see RFC1951 Page5 Section 3.1.1\n      if bitlen <= 9 then -- Have cached reverse for small bitlen.\n        symbol_huffman_codes[symbol] = _reverse_bits_tbl[bitlen][huffman_code]\n      else\n        local reverse = 0\n        for _ = 1, bitlen do\n          reverse = reverse - reverse % 2 +\n                      (((reverse % 2 == 1) or (huffman_code % 2) == 1) and 1 or\n                        0)\n          huffman_code = (huffman_code - huffman_code % 2) / 2\n          reverse = reverse * 2\n        end\n        symbol_huffman_codes[symbol] = (reverse - reverse % 2) / 2\n      end\n    end\n  end\n  return symbol_huffman_codes\nend\n\n-- A helper function to sort heap elements\n-- a[1], b[1] is the huffman frequency\n-- a[2], b[2] is the symbol value.\nlocal function SortByFirstThenSecond(a, b)\n  return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\nend\n\n-- Calculate the huffman bit length and huffman code.\n-- @param symbol_count: A table whose table key is the symbol, and table value\n--		is the symbol frenquency (nil means 0 frequency).\n-- @param max_bitlen: See description of return value.\n-- @param max_symbol: The maximum symbol\n-- @return a table whose key is the symbol, and the value is the huffman bit\n--		bit length. We guarantee that all bit length <= max_bitlen.\n--		For 0<=symbol<=max_symbol, table value could be nil if the frequency\n--		of the symbol is 0 or nil.\n-- @return a table whose key is the symbol, and the value is the huffman code.\n-- @return a number indicating the maximum symbol whose bitlen is not 0.\nlocal function GetHuffmanBitlenAndCode(symbol_counts, max_bitlen, max_symbol)\n  local heap_size\n  local max_non_zero_bitlen_symbol = -1\n  local leafs = {}\n  local heap = {}\n  local symbol_bitlens = {}\n  local symbol_codes = {}\n  local bitlen_counts = {}\n\n  --[[\n		tree[1]: weight, temporarily used as parent and bitLengths\n		tree[2]: symbol\n		tree[3]: left child\n		tree[4]: right child\n	--]]\n  local number_unique_symbols = 0\n  for symbol, count in pairs(symbol_counts) do\n    number_unique_symbols = number_unique_symbols + 1\n    leafs[number_unique_symbols] = {count, symbol}\n  end\n\n  if (number_unique_symbols == 0) then\n    -- no code.\n    return {}, {}, -1\n  elseif (number_unique_symbols == 1) then\n    -- Only one code. In this case, its huffman code\n    -- needs to be assigned as 0, and bit length is 1.\n    -- This is the only case that the return result\n    -- represents an imcomplete huffman tree.\n    local symbol = leafs[1][2]\n    symbol_bitlens[symbol] = 1\n    symbol_codes[symbol] = 0\n    return symbol_bitlens, symbol_codes, symbol\n  else\n    table_sort(leafs, SortByFirstThenSecond)\n    heap_size = number_unique_symbols\n    for i = 1, heap_size do heap[i] = leafs[i] end\n\n    while (heap_size > 1) do\n      -- Note: pop does not change table size of heap\n      local leftChild = MinHeapPop(heap, heap_size)\n      heap_size = heap_size - 1\n      local rightChild = MinHeapPop(heap, heap_size)\n      heap_size = heap_size - 1\n      local newNode = {leftChild[1] + rightChild[1], -1, leftChild, rightChild}\n      MinHeapPush(heap, newNode, heap_size)\n      heap_size = heap_size + 1\n    end\n\n    -- Number of leafs whose bit length is greater than max_len.\n    local number_bitlen_overflow = 0\n\n    -- Calculate bit length of all nodes\n    local fifo = {heap[1], 0, 0, 0} -- preallocate some spaces.\n    local fifo_size = 1\n    local index = 1\n    heap[1][1] = 0\n    while (index <= fifo_size) do -- Breath first search\n      local e = fifo[index]\n      local bitlen = e[1]\n      local symbol = e[2]\n      local left_child = e[3]\n      local right_child = e[4]\n      if left_child then\n        fifo_size = fifo_size + 1\n        fifo[fifo_size] = left_child\n        left_child[1] = bitlen + 1\n      end\n      if right_child then\n        fifo_size = fifo_size + 1\n        fifo[fifo_size] = right_child\n        right_child[1] = bitlen + 1\n      end\n      index = index + 1\n\n      if (bitlen > max_bitlen) then\n        number_bitlen_overflow = number_bitlen_overflow + 1\n        bitlen = max_bitlen\n      end\n      if symbol >= 0 then\n        symbol_bitlens[symbol] = bitlen\n        max_non_zero_bitlen_symbol = (symbol > max_non_zero_bitlen_symbol) and\n                                       symbol or max_non_zero_bitlen_symbol\n        bitlen_counts[bitlen] = (bitlen_counts[bitlen] or 0) + 1\n      end\n    end\n\n    -- Resolve bit length overflow\n    -- @see ZLib/trees.c:gen_bitlen(s, desc), for reference\n    if (number_bitlen_overflow > 0) then\n      repeat\n        local bitlen = max_bitlen - 1\n        while ((bitlen_counts[bitlen] or 0) == 0) do bitlen = bitlen - 1 end\n        -- move one leaf down the tree\n        bitlen_counts[bitlen] = bitlen_counts[bitlen] - 1\n        -- move one overflow item as its brother\n        bitlen_counts[bitlen + 1] = (bitlen_counts[bitlen + 1] or 0) + 2\n        bitlen_counts[max_bitlen] = bitlen_counts[max_bitlen] - 1\n        number_bitlen_overflow = number_bitlen_overflow - 2\n      until (number_bitlen_overflow <= 0)\n\n      index = 1\n      for bitlen = max_bitlen, 1, -1 do\n        local n = bitlen_counts[bitlen] or 0\n        while (n > 0) do\n          local symbol = leafs[index][2]\n          symbol_bitlens[symbol] = bitlen\n          n = n - 1\n          index = index + 1\n        end\n      end\n    end\n\n    symbol_codes = GetHuffmanCodeFromBitlen(bitlen_counts, symbol_bitlens,\n                                            max_symbol, max_bitlen)\n    return symbol_bitlens, symbol_codes, max_non_zero_bitlen_symbol\n  end\nend\n\n-- Calculate the first huffman header in the dynamic huffman block\n-- @see RFC1951 Page 12\n-- @param lcode_bitlen: The huffman bit length of literal/LZ77_length.\n-- @param max_non_zero_bitlen_lcode: The maximum literal/LZ77_length symbol\n--		whose huffman bit length is not zero.\n-- @param dcode_bitlen: The huffman bit length of LZ77 distance.\n-- @param max_non_zero_bitlen_dcode: The maximum LZ77 distance symbol\n--		whose huffman bit length is not zero.\n-- @return The run length encoded codes.\n-- @return The extra bits. One entry for each rle code that needs extra bits.\n--		(code == 16 or 17 or 18).\n-- @return The count of appearance of each rle codes.\nlocal function RunLengthEncodeHuffmanBitlen(lcode_bitlens,\n                                            max_non_zero_bitlen_lcode,\n                                            dcode_bitlens,\n                                            max_non_zero_bitlen_dcode)\n  local rle_code_tblsize = 0\n  local rle_codes = {}\n  local rle_code_counts = {}\n  local rle_extra_bits_tblsize = 0\n  local rle_extra_bits = {}\n  local prev = nil\n  local count = 0\n\n  -- If there is no distance code, assume one distance code of bit length 0.\n  -- RFC1951: One distance code of zero bits means that\n  -- there are no distance codes used at all (the data is all literals).\n  max_non_zero_bitlen_dcode = (max_non_zero_bitlen_dcode < 0) and 0 or\n                                max_non_zero_bitlen_dcode\n  local max_code = max_non_zero_bitlen_lcode + max_non_zero_bitlen_dcode + 1\n\n  for code = 0, max_code + 1 do\n    local len = (code <= max_non_zero_bitlen_lcode) and\n                  (lcode_bitlens[code] or 0) or ((code <= max_code) and\n                  (dcode_bitlens[code - max_non_zero_bitlen_lcode - 1] or 0) or\n                  nil)\n    if len == prev then\n      count = count + 1\n      if len ~= 0 and count == 6 then\n        rle_code_tblsize = rle_code_tblsize + 1\n        rle_codes[rle_code_tblsize] = 16\n        rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1\n        rle_extra_bits[rle_extra_bits_tblsize] = 3\n        rle_code_counts[16] = (rle_code_counts[16] or 0) + 1\n        count = 0\n      elseif len == 0 and count == 138 then\n        rle_code_tblsize = rle_code_tblsize + 1\n        rle_codes[rle_code_tblsize] = 18\n        rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1\n        rle_extra_bits[rle_extra_bits_tblsize] = 127\n        rle_code_counts[18] = (rle_code_counts[18] or 0) + 1\n        count = 0\n      end\n    else\n      if count == 1 then\n        rle_code_tblsize = rle_code_tblsize + 1\n        rle_codes[rle_code_tblsize] = prev\n        rle_code_counts[prev] = (rle_code_counts[prev] or 0) + 1\n      elseif count == 2 then\n        rle_code_tblsize = rle_code_tblsize + 1\n        rle_codes[rle_code_tblsize] = prev\n        rle_code_tblsize = rle_code_tblsize + 1\n        rle_codes[rle_code_tblsize] = prev\n        rle_code_counts[prev] = (rle_code_counts[prev] or 0) + 2\n      elseif count >= 3 then\n        rle_code_tblsize = rle_code_tblsize + 1\n        local rleCode = (prev ~= 0) and 16 or (count <= 10 and 17 or 18)\n        rle_codes[rle_code_tblsize] = rleCode\n        rle_code_counts[rleCode] = (rle_code_counts[rleCode] or 0) + 1\n        rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1\n        rle_extra_bits[rle_extra_bits_tblsize] =\n          (count <= 10) and (count - 3) or (count - 11)\n      end\n\n      prev = len\n      if len and len ~= 0 then\n        rle_code_tblsize = rle_code_tblsize + 1\n        rle_codes[rle_code_tblsize] = len\n        rle_code_counts[len] = (rle_code_counts[len] or 0) + 1\n        count = 0\n      else\n        count = 1\n      end\n    end\n  end\n\n  return rle_codes, rle_extra_bits, rle_code_counts\nend\n\n-- Load the string into a table, in order to speed up LZ77.\n-- Loop unrolled 16 times to speed this function up.\n-- @param str The string to be loaded.\n-- @param t The load destination\n-- @param start str[index] will be the first character to be loaded.\n-- @param end str[index] will be the last character to be loaded\n-- @param offset str[index] will be loaded into t[index-offset]\n-- @return t\nlocal function LoadStringToTable(str, t, start, stop, offset)\n  local i = start - offset\n  while i <= stop - 15 - offset do\n    t[i], t[i + 1], t[i + 2], t[i + 3], t[i + 4], t[i + 5], t[i + 6], t[i + 7], t[i +\n      8], t[i + 9], t[i + 10], t[i + 11], t[i + 12], t[i + 13], t[i + 14], t[i +\n      15] = string_byte(str, i + offset, i + 15 + offset)\n    i = i + 16\n  end\n  while (i <= stop - offset) do\n    t[i] = string_byte(str, i + offset, i + offset)\n    i = i + 1\n  end\n  return t\nend\n\n-- Do LZ77 process. This function uses the majority of the CPU time.\n-- @see zlib/deflate.c:deflate_fast(), zlib/deflate.c:deflate_slow()\n-- @see https://github.com/madler/zlib/blob/master/doc/algorithm.txt\n-- This function uses the algorithms used above. You should read the\n-- algorithm.txt above to understand what is the hash function and the\n-- lazy evaluation.\n--\n-- The special optimization used here is hash functions used here.\n-- The hash function is just the multiplication of the three consective\n-- characters. So if the hash matches, it guarantees 3 characters are matched.\n-- This optimization can be implemented because Lua table is a hash table.\n--\n-- @param level integer that describes compression level.\n-- @param string_table table that stores the value of string to be compressed.\n--			The index of this table starts from 1.\n--			The caller needs to make sure all values needed by this function\n--			are loaded.\n--			Assume \"str\" is the origin input string into the compressor\n--			str[block_start]..str[block_end+3] needs to be loaded into\n--			string_table[block_start-offset]..string_table[block_end-offset]\n--			If dictionary is presented, the last 258 bytes of the dictionary\n--			needs to be loaded into sing_table[-257..0]\n--			(See more in the description of offset.)\n-- @param hash_tables. The table key is the hash value (0<=hash<=16777216=256^3)\n--			The table value is an array0 that stores the indexes of the\n--			input data string to be compressed, such that\n--			hash == str[index]*str[index+1]*str[index+2]\n--			Indexes are ordered in this array.\n-- @param block_start The indexes of the input data string to be compressed.\n--				that starts the LZ77 block.\n-- @param block_end The indexes of the input data string to be compressed.\n--				that stores the LZ77 block.\n-- @param offset str[index] is stored in string_table[index-offset],\n--			This offset is mainly an optimization to limit the index\n--			of string_table, so lua can access this table quicker.\n-- @param dictionary See LibDeflate:CreateDictionary\n-- @return literal/LZ77_length deflate codes.\n-- @return the extra bits of literal/LZ77_length deflate codes.\n-- @return the count of each literal/LZ77 deflate code.\n-- @return LZ77 distance deflate codes.\n-- @return the extra bits of LZ77 distance deflate codes.\n-- @return the count of each LZ77 distance deflate code.\nlocal function GetBlockLZ77Result(level, string_table, hash_tables, block_start,\n                                  block_end, offset, dictionary)\n  local config = _compression_level_configs[level]\n  local config_use_lazy, config_good_prev_length, config_max_lazy_match,\n        config_nice_length, config_max_hash_chain = config[1], config[2],\n                                                    config[3], config[4],\n                                                    config[5]\n\n  local config_max_insert_length = (not config_use_lazy) and\n                                     config_max_lazy_match or 2147483646\n  local config_good_hash_chain =\n    (config_max_hash_chain - config_max_hash_chain % 4 / 4)\n\n  local hash\n\n  local dict_hash_tables\n  local dict_string_table\n  local dict_string_len = 0\n\n  if dictionary then\n    dict_hash_tables = dictionary.hash_tables\n    dict_string_table = dictionary.string_table\n    dict_string_len = dictionary.strlen\n    assert(block_start == 1)\n    if block_end >= block_start and dict_string_len >= 2 then\n      hash = dict_string_table[dict_string_len - 1] * 65536 +\n               dict_string_table[dict_string_len] * 256 + string_table[1]\n      local t = hash_tables[hash]\n      if not t then\n        t = {};\n        hash_tables[hash] = t\n      end\n      t[#t + 1] = -1\n    end\n    if block_end >= block_start + 1 and dict_string_len >= 1 then\n      hash =\n        dict_string_table[dict_string_len] * 65536 + string_table[1] * 256 +\n          string_table[2]\n      local t = hash_tables[hash]\n      if not t then\n        t = {};\n        hash_tables[hash] = t\n      end\n      t[#t + 1] = 0\n    end\n  end\n\n  local dict_string_len_plus3 = dict_string_len + 3\n\n  hash = (string_table[block_start - offset] or 0) * 256 +\n           (string_table[block_start + 1 - offset] or 0)\n\n  local lcodes = {}\n  local lcode_tblsize = 0\n  local lcodes_counts = {}\n  local dcodes = {}\n  local dcodes_tblsize = 0\n  local dcodes_counts = {}\n\n  local lextra_bits = {}\n  local lextra_bits_tblsize = 0\n  local dextra_bits = {}\n  local dextra_bits_tblsize = 0\n\n  local match_available = false\n  local prev_len\n  local prev_dist\n  local cur_len = 0\n  local cur_dist = 0\n\n  local index = block_start\n  local index_end = block_end + (config_use_lazy and 1 or 0)\n\n  -- the zlib source code writes separate code for lazy evaluation and\n  -- not lazy evaluation, which is easier to understand.\n  -- I put them together, so it is a bit harder to understand.\n  -- because I think this is easier for me to maintain it.\n  while (index <= index_end) do\n    local string_table_index = index - offset\n    local offset_minus_three = offset - 3\n    prev_len = cur_len\n    prev_dist = cur_dist\n    cur_len = 0\n\n    hash = (hash * 256 + (string_table[string_table_index + 2] or 0)) % 16777216\n\n    local chain_index\n    local cur_chain\n    local hash_chain = hash_tables[hash]\n    local chain_old_size\n    if not hash_chain then\n      chain_old_size = 0\n      hash_chain = {}\n      hash_tables[hash] = hash_chain\n      if dict_hash_tables then\n        cur_chain = dict_hash_tables[hash]\n        chain_index = cur_chain and #cur_chain or 0\n      else\n        chain_index = 0\n      end\n    else\n      chain_old_size = #hash_chain\n      cur_chain = hash_chain\n      chain_index = chain_old_size\n    end\n\n    if index <= block_end then hash_chain[chain_old_size + 1] = index end\n\n    if (chain_index > 0 and index + 2 <= block_end and\n      (not config_use_lazy or prev_len < config_max_lazy_match)) then\n\n      local depth =\n        (config_use_lazy and prev_len >= config_good_prev_length) and\n          config_good_hash_chain or config_max_hash_chain\n\n      local max_len_minus_one = block_end - index\n      max_len_minus_one = (max_len_minus_one >= 257) and 257 or\n                            max_len_minus_one\n      max_len_minus_one = max_len_minus_one + string_table_index\n      local string_table_index_plus_three = string_table_index + 3\n\n      while chain_index >= 1 and depth > 0 do\n        local prev = cur_chain[chain_index]\n\n        if index - prev > 32768 then break end\n        if prev < index then\n          local sj = string_table_index_plus_three\n\n          if prev >= -257 then\n            local pj = prev - offset_minus_three\n            while (sj <= max_len_minus_one and string_table[pj] ==\n              string_table[sj]) do\n              sj = sj + 1\n              pj = pj + 1\n            end\n          else\n            local pj = dict_string_len_plus3 + prev\n            while (sj <= max_len_minus_one and dict_string_table[pj] ==\n              string_table[sj]) do\n              sj = sj + 1\n              pj = pj + 1\n            end\n          end\n          local j = sj - string_table_index\n          if j > cur_len then\n            cur_len = j\n            cur_dist = index - prev\n          end\n          if cur_len >= config_nice_length then break end\n        end\n\n        chain_index = chain_index - 1\n        depth = depth - 1\n        if chain_index == 0 and prev > 0 and dict_hash_tables then\n          cur_chain = dict_hash_tables[hash]\n          chain_index = cur_chain and #cur_chain or 0\n        end\n      end\n    end\n\n    if not config_use_lazy then prev_len, prev_dist = cur_len, cur_dist end\n    if ((not config_use_lazy or match_available) and\n      (prev_len > 3 or (prev_len == 3 and prev_dist < 4096)) and cur_len <=\n      prev_len) then\n      local code = _length_to_deflate_code[prev_len]\n      local length_extra_bits_bitlen = _length_to_deflate_extra_bitlen[prev_len]\n      local dist_code, dist_extra_bits_bitlen, dist_extra_bits\n      if prev_dist <= 256 then -- have cached code for small distance.\n        dist_code = _dist256_to_deflate_code[prev_dist]\n        dist_extra_bits = _dist256_to_deflate_extra_bits[prev_dist]\n        dist_extra_bits_bitlen = _dist256_to_deflate_extra_bitlen[prev_dist]\n      else\n        dist_code = 16\n        dist_extra_bits_bitlen = 7\n        local a = 384\n        local b = 512\n\n        while true do\n          if prev_dist <= a then\n            dist_extra_bits = (prev_dist - (b / 2) - 1) % (b / 4)\n            break\n          elseif prev_dist <= b then\n            dist_extra_bits = (prev_dist - (b / 2) - 1) % (b / 4)\n            dist_code = dist_code + 1\n            break\n          else\n            dist_code = dist_code + 2\n            dist_extra_bits_bitlen = dist_extra_bits_bitlen + 1\n            a = a * 2\n            b = b * 2\n          end\n        end\n      end\n      lcode_tblsize = lcode_tblsize + 1\n      lcodes[lcode_tblsize] = code\n      lcodes_counts[code] = (lcodes_counts[code] or 0) + 1\n\n      dcodes_tblsize = dcodes_tblsize + 1\n      dcodes[dcodes_tblsize] = dist_code\n      dcodes_counts[dist_code] = (dcodes_counts[dist_code] or 0) + 1\n\n      if length_extra_bits_bitlen > 0 then\n        local lenExtraBits = _length_to_deflate_extra_bits[prev_len]\n        lextra_bits_tblsize = lextra_bits_tblsize + 1\n        lextra_bits[lextra_bits_tblsize] = lenExtraBits\n      end\n      if dist_extra_bits_bitlen > 0 then\n        dextra_bits_tblsize = dextra_bits_tblsize + 1\n        dextra_bits[dextra_bits_tblsize] = dist_extra_bits\n      end\n\n      for i = index + 1, index + prev_len - (config_use_lazy and 2 or 1) do\n        hash = (hash * 256 + (string_table[i - offset + 2] or 0)) % 16777216\n        if prev_len <= config_max_insert_length then\n          hash_chain = hash_tables[hash]\n          if not hash_chain then\n            hash_chain = {}\n            hash_tables[hash] = hash_chain\n          end\n          hash_chain[#hash_chain + 1] = i\n        end\n      end\n      index = index + prev_len - (config_use_lazy and 1 or 0)\n      match_available = false\n    elseif (not config_use_lazy) or match_available then\n      local code = string_table[config_use_lazy and (string_table_index - 1) or\n                     string_table_index]\n      lcode_tblsize = lcode_tblsize + 1\n      lcodes[lcode_tblsize] = code\n      lcodes_counts[code] = (lcodes_counts[code] or 0) + 1\n      index = index + 1\n    else\n      match_available = true\n      index = index + 1\n    end\n  end\n\n  -- Write \"end of block\" symbol\n  lcode_tblsize = lcode_tblsize + 1\n  lcodes[lcode_tblsize] = 256\n  lcodes_counts[256] = (lcodes_counts[256] or 0) + 1\n\n  return lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits, dcodes_counts\nend\n\n-- Get the header data of dynamic block.\n-- @param lcodes_count The count of each literal/LZ77_length codes.\n-- @param dcodes_count The count of each Lz77 distance codes.\n-- @return a lots of stuffs.\n-- @see RFC1951 Page 12\nlocal function GetBlockDynamicHuffmanHeader(lcodes_counts, dcodes_counts)\n  local lcodes_huffman_bitlens, lcodes_huffman_codes, max_non_zero_bitlen_lcode =\n    GetHuffmanBitlenAndCode(lcodes_counts, 15, 285)\n  local dcodes_huffman_bitlens, dcodes_huffman_codes, max_non_zero_bitlen_dcode =\n    GetHuffmanBitlenAndCode(dcodes_counts, 15, 29)\n\n  local rle_deflate_codes, rle_extra_bits, rle_codes_counts =\n    RunLengthEncodeHuffmanBitlen(lcodes_huffman_bitlens,\n                                 max_non_zero_bitlen_lcode,\n                                 dcodes_huffman_bitlens,\n                                 max_non_zero_bitlen_dcode)\n\n  local rle_codes_huffman_bitlens, rle_codes_huffman_codes =\n    GetHuffmanBitlenAndCode(rle_codes_counts, 7, 18)\n\n  local HCLEN = 0\n  for i = 1, 19 do\n    local symbol = _rle_codes_huffman_bitlen_order[i]\n    local length = rle_codes_huffman_bitlens[symbol] or 0\n    if length ~= 0 then HCLEN = i end\n  end\n\n  HCLEN = HCLEN - 4\n  local HLIT = max_non_zero_bitlen_lcode + 1 - 257\n  local HDIST = max_non_zero_bitlen_dcode + 1 - 1\n  if HDIST < 0 then HDIST = 0 end\n\n  return HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens, rle_codes_huffman_codes,\n         rle_deflate_codes, rle_extra_bits, lcodes_huffman_bitlens,\n         lcodes_huffman_codes, dcodes_huffman_bitlens, dcodes_huffman_codes\nend\n\n-- Get the size of dynamic block without writing any bits into the writer.\n-- @param ... Read the source code of GetBlockDynamicHuffmanHeader()\n-- @return the bit length of the dynamic block\nlocal function GetDynamicHuffmanBlockSize(lcodes, dcodes, HCLEN,\n                                          rle_codes_huffman_bitlens,\n                                          rle_deflate_codes,\n                                          lcodes_huffman_bitlens,\n                                          dcodes_huffman_bitlens)\n\n  local block_bitlen = 17 -- 1+2+5+5+4\n  block_bitlen = block_bitlen + (HCLEN + 4) * 3\n\n  for i = 1, #rle_deflate_codes do\n    local code = rle_deflate_codes[i]\n    block_bitlen = block_bitlen + rle_codes_huffman_bitlens[code]\n    if code >= 16 then\n      block_bitlen = block_bitlen +\n                       ((code == 16) and 2 or (code == 17 and 3 or 7))\n    end\n  end\n\n  local length_code_count = 0\n  for i = 1, #lcodes do\n    local code = lcodes[i]\n    local huffman_bitlen = lcodes_huffman_bitlens[code]\n    block_bitlen = block_bitlen + huffman_bitlen\n    if code > 256 then -- Length code\n      length_code_count = length_code_count + 1\n      if code > 264 and code < 285 then -- Length code with extra bits\n        local extra_bits_bitlen = _literal_deflate_code_to_extra_bitlen[code -\n                                    256]\n        block_bitlen = block_bitlen + extra_bits_bitlen\n      end\n      local dist_code = dcodes[length_code_count]\n      local dist_huffman_bitlen = dcodes_huffman_bitlens[dist_code]\n      block_bitlen = block_bitlen + dist_huffman_bitlen\n\n      if dist_code > 3 then -- dist code with extra bits\n        local dist_extra_bits_bitlen = (dist_code - dist_code % 2) / 2 - 1\n        block_bitlen = block_bitlen + dist_extra_bits_bitlen\n      end\n    end\n  end\n  return block_bitlen\nend\n\n-- Write dynamic block.\n-- @param ... Read the source code of GetBlockDynamicHuffmanHeader()\nlocal function CompressDynamicHuffmanBlock(WriteBits, is_last_block, lcodes,\n                                           lextra_bits, dcodes, dextra_bits,\n                                           HLIT, HDIST, HCLEN,\n                                           rle_codes_huffman_bitlens,\n                                           rle_codes_huffman_codes,\n                                           rle_deflate_codes, rle_extra_bits,\n                                           lcodes_huffman_bitlens,\n                                           lcodes_huffman_codes,\n                                           dcodes_huffman_bitlens,\n                                           dcodes_huffman_codes)\n\n  WriteBits(is_last_block and 1 or 0, 1) -- Last block identifier\n  WriteBits(2, 2) -- Dynamic Huffman block identifier\n\n  WriteBits(HLIT, 5)\n  WriteBits(HDIST, 5)\n  WriteBits(HCLEN, 4)\n\n  for i = 1, HCLEN + 4 do\n    local symbol = _rle_codes_huffman_bitlen_order[i]\n    local length = rle_codes_huffman_bitlens[symbol] or 0\n    WriteBits(length, 3)\n  end\n\n  local rleExtraBitsIndex = 1\n  for i = 1, #rle_deflate_codes do\n    local code = rle_deflate_codes[i]\n    WriteBits(rle_codes_huffman_codes[code], rle_codes_huffman_bitlens[code])\n    if code >= 16 then\n      local extraBits = rle_extra_bits[rleExtraBitsIndex]\n      WriteBits(extraBits, (code == 16) and 2 or (code == 17 and 3 or 7))\n      rleExtraBitsIndex = rleExtraBitsIndex + 1\n    end\n  end\n\n  local length_code_count = 0\n  local length_code_with_extra_count = 0\n  local dist_code_with_extra_count = 0\n\n  for i = 1, #lcodes do\n    local deflate_codee = lcodes[i]\n    local huffman_code = lcodes_huffman_codes[deflate_codee]\n    local huffman_bitlen = lcodes_huffman_bitlens[deflate_codee]\n    WriteBits(huffman_code, huffman_bitlen)\n    if deflate_codee > 256 then -- Length code\n      length_code_count = length_code_count + 1\n      if deflate_codee > 264 and deflate_codee < 285 then\n        -- Length code with extra bits\n        length_code_with_extra_count = length_code_with_extra_count + 1\n        local extra_bits = lextra_bits[length_code_with_extra_count]\n        local extra_bits_bitlen =\n          _literal_deflate_code_to_extra_bitlen[deflate_codee - 256]\n        WriteBits(extra_bits, extra_bits_bitlen)\n      end\n      -- Write distance code\n      local dist_deflate_code = dcodes[length_code_count]\n      local dist_huffman_code = dcodes_huffman_codes[dist_deflate_code]\n      local dist_huffman_bitlen = dcodes_huffman_bitlens[dist_deflate_code]\n      WriteBits(dist_huffman_code, dist_huffman_bitlen)\n\n      if dist_deflate_code > 3 then -- dist code with extra bits\n        dist_code_with_extra_count = dist_code_with_extra_count + 1\n        local dist_extra_bits = dextra_bits[dist_code_with_extra_count]\n        local dist_extra_bits_bitlen = (dist_deflate_code - dist_deflate_code %\n                                         2) / 2 - 1\n        WriteBits(dist_extra_bits, dist_extra_bits_bitlen)\n      end\n    end\n  end\nend\n\n-- Get the size of fixed block without writing any bits into the writer.\n-- @param lcodes literal/LZ77_length deflate codes\n-- @param decodes LZ77 distance deflate codes\n-- @return the bit length of the fixed block\nlocal function GetFixedHuffmanBlockSize(lcodes, dcodes)\n  local block_bitlen = 3\n  local length_code_count = 0\n  for i = 1, #lcodes do\n    local code = lcodes[i]\n    local huffman_bitlen = _fix_block_literal_huffman_bitlen[code]\n    block_bitlen = block_bitlen + huffman_bitlen\n    if code > 256 then -- Length code\n      length_code_count = length_code_count + 1\n      if code > 264 and code < 285 then -- Length code with extra bits\n        local extra_bits_bitlen = _literal_deflate_code_to_extra_bitlen[code -\n                                    256]\n        block_bitlen = block_bitlen + extra_bits_bitlen\n      end\n      local dist_code = dcodes[length_code_count]\n      block_bitlen = block_bitlen + 5\n\n      if dist_code > 3 then -- dist code with extra bits\n        local dist_extra_bits_bitlen = (dist_code - dist_code % 2) / 2 - 1\n        block_bitlen = block_bitlen + dist_extra_bits_bitlen\n      end\n    end\n  end\n  return block_bitlen\nend\n\n-- Write fixed block.\n-- @param lcodes literal/LZ77_length deflate codes\n-- @param decodes LZ77 distance deflate codes\nlocal function CompressFixedHuffmanBlock(WriteBits, is_last_block, lcodes,\n                                         lextra_bits, dcodes, dextra_bits)\n  WriteBits(is_last_block and 1 or 0, 1) -- Last block identifier\n  WriteBits(1, 2) -- Fixed Huffman block identifier\n  local length_code_count = 0\n  local length_code_with_extra_count = 0\n  local dist_code_with_extra_count = 0\n  for i = 1, #lcodes do\n    local deflate_code = lcodes[i]\n    local huffman_code = _fix_block_literal_huffman_code[deflate_code]\n    local huffman_bitlen = _fix_block_literal_huffman_bitlen[deflate_code]\n    WriteBits(huffman_code, huffman_bitlen)\n    if deflate_code > 256 then -- Length code\n      length_code_count = length_code_count + 1\n      if deflate_code > 264 and deflate_code < 285 then\n        -- Length code with extra bits\n        length_code_with_extra_count = length_code_with_extra_count + 1\n        local extra_bits = lextra_bits[length_code_with_extra_count]\n        local extra_bits_bitlen =\n          _literal_deflate_code_to_extra_bitlen[deflate_code - 256]\n        WriteBits(extra_bits, extra_bits_bitlen)\n      end\n      -- Write distance code\n      local dist_code = dcodes[length_code_count]\n      local dist_huffman_code = _fix_block_dist_huffman_code[dist_code]\n      WriteBits(dist_huffman_code, 5)\n\n      if dist_code > 3 then -- dist code with extra bits\n        dist_code_with_extra_count = dist_code_with_extra_count + 1\n        local dist_extra_bits = dextra_bits[dist_code_with_extra_count]\n        local dist_extra_bits_bitlen = (dist_code - dist_code % 2) / 2 - 1\n        WriteBits(dist_extra_bits, dist_extra_bits_bitlen)\n      end\n    end\n  end\nend\n\n-- Get the size of store block without writing any bits into the writer.\n-- @param block_start The start index of the origin input string\n-- @param block_end The end index of the origin input string\n-- @param Total bit lens had been written into the compressed result before,\n-- because store block needs to shift to byte boundary.\n-- @return the bit length of the fixed block\nlocal function GetStoreBlockSize(block_start, block_end, total_bitlen)\n  assert(block_end - block_start + 1 <= 65535)\n  local block_bitlen = 3\n  total_bitlen = total_bitlen + 3\n  local padding_bitlen = (8 - total_bitlen % 8) % 8\n  block_bitlen = block_bitlen + padding_bitlen\n  block_bitlen = block_bitlen + 32\n  block_bitlen = block_bitlen + (block_end - block_start + 1) * 8\n  return block_bitlen\nend\n\n-- Write the store block.\n-- @param ... lots of stuffs\n-- @return nil\nlocal function CompressStoreBlock(WriteBits, WriteString, is_last_block, str,\n                                  block_start, block_end, total_bitlen)\n  assert(block_end - block_start + 1 <= 65535)\n  WriteBits(is_last_block and 1 or 0, 1) -- Last block identifer.\n  WriteBits(0, 2) -- Store block identifier.\n  total_bitlen = total_bitlen + 3\n  local padding_bitlen = (8 - total_bitlen % 8) % 8\n  if padding_bitlen > 0 then\n    WriteBits(_pow2[padding_bitlen] - 1, padding_bitlen)\n  end\n  local size = block_end - block_start + 1\n  WriteBits(size, 16)\n\n  -- Write size's one's complement\n  local comp = (255 - size % 256) + (255 - (size - size % 256) / 256) * 256\n  WriteBits(comp, 16)\n\n  WriteString(str:sub(block_start, block_end))\nend\n\n-- Do the deflate\n-- Currently using a simple way to determine the block size\n-- (This is why the compression ratio is little bit worse than zlib when\n-- the input size is very large\n-- The first block is 64KB, the following block is 32KB.\n-- After each block, there is a memory cleanup operation.\n-- This is not a fast operation, but it is needed to save memory usage, so\n-- the memory usage does not grow unboundly. If the data size is less than\n-- 64KB, then memory cleanup won't happen.\n-- This function determines whether to use store/fixed/dynamic blocks by\n-- calculating the block size of each block type and chooses the smallest one.\nlocal function Deflate(configs, WriteBits, WriteString, FlushWriter, str,\n                       dictionary)\n  local string_table = {}\n  local hash_tables = {}\n  local is_last_block = nil\n  local block_start\n  local block_end\n  local bitlen_written\n  local total_bitlen = FlushWriter(_FLUSH_MODE_NO_FLUSH)\n  local strlen = #str\n  local offset\n\n  local level\n  local strategy\n  if configs then\n    if configs.level then level = configs.level end\n    if configs.strategy then strategy = configs.strategy end\n  end\n\n  if not level then\n    if strlen < 2048 then\n      level = 7\n    elseif strlen > 65536 then\n      level = 3\n    else\n      level = 5\n    end\n  end\n\n  while not is_last_block do\n    if not block_start then\n      block_start = 1\n      block_end = 64 * 1024 - 1\n      offset = 0\n    else\n      block_start = block_end + 1\n      block_end = block_end + 32 * 1024\n      offset = block_start - 32 * 1024 - 1\n    end\n\n    if block_end >= strlen then\n      block_end = strlen\n      is_last_block = true\n    else\n      is_last_block = false\n    end\n\n    local lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits, dcodes_counts\n\n    local HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens,\n          rle_codes_huffman_codes, rle_deflate_codes, rle_extra_bits,\n          lcodes_huffman_bitlens, lcodes_huffman_codes, dcodes_huffman_bitlens,\n          dcodes_huffman_codes\n\n    local dynamic_block_bitlen\n    local fixed_block_bitlen\n    local store_block_bitlen\n\n    if level ~= 0 then\n\n      -- GetBlockLZ77 needs block_start to block_end+3 to be loaded.\n      LoadStringToTable(str, string_table, block_start, block_end + 3, offset)\n      if block_start == 1 and dictionary then\n        local dict_string_table = dictionary.string_table\n        local dict_strlen = dictionary.strlen\n        for i = 0, (-dict_strlen + 1) < -257 and -257 or (-dict_strlen + 1), -1 do\n          string_table[i] = dict_string_table[dict_strlen + i]\n        end\n      end\n\n      if strategy == \"huffman_only\" then\n        lcodes = {}\n        LoadStringToTable(str, lcodes, block_start, block_end, block_start - 1)\n        lextra_bits = {}\n        lcodes_counts = {}\n        lcodes[block_end - block_start + 2] = 256 -- end of block\n        for i = 1, block_end - block_start + 2 do\n          local code = lcodes[i]\n          lcodes_counts[code] = (lcodes_counts[code] or 0) + 1\n        end\n        dcodes = {}\n        dextra_bits = {}\n        dcodes_counts = {}\n      else\n        lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits, dcodes_counts =\n          GetBlockLZ77Result(level, string_table, hash_tables, block_start,\n                             block_end, offset, dictionary)\n      end\n\n      -- LuaFormatter off\n      HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens, rle_codes_huffman_codes, rle_deflate_codes,\n       rle_extra_bits, lcodes_huffman_bitlens, lcodes_huffman_codes, dcodes_huffman_bitlens, dcodes_huffman_codes =\n      -- LuaFormatter on\n      GetBlockDynamicHuffmanHeader(lcodes_counts, dcodes_counts)\n      dynamic_block_bitlen = GetDynamicHuffmanBlockSize(lcodes, dcodes, HCLEN,\n                                                        rle_codes_huffman_bitlens,\n                                                        rle_deflate_codes,\n                                                        lcodes_huffman_bitlens,\n                                                        dcodes_huffman_bitlens)\n      fixed_block_bitlen = GetFixedHuffmanBlockSize(lcodes, dcodes)\n    end\n\n    store_block_bitlen = GetStoreBlockSize(block_start, block_end, total_bitlen)\n\n    local min_bitlen = store_block_bitlen\n    min_bitlen = (fixed_block_bitlen and fixed_block_bitlen < min_bitlen) and\n                   fixed_block_bitlen or min_bitlen\n    min_bitlen =\n      (dynamic_block_bitlen and dynamic_block_bitlen < min_bitlen) and\n        dynamic_block_bitlen or min_bitlen\n\n    if level == 0 or\n      (strategy ~= \"fixed\" and strategy ~= \"dynamic\" and store_block_bitlen ==\n        min_bitlen) then\n      CompressStoreBlock(WriteBits, WriteString, is_last_block, str,\n                         block_start, block_end, total_bitlen)\n      total_bitlen = total_bitlen + store_block_bitlen\n    elseif strategy ~= \"dynamic\" and\n      (strategy == \"fixed\" or fixed_block_bitlen == min_bitlen) then\n      CompressFixedHuffmanBlock(WriteBits, is_last_block, lcodes, lextra_bits,\n                                dcodes, dextra_bits)\n      total_bitlen = total_bitlen + fixed_block_bitlen\n    elseif strategy == \"dynamic\" or dynamic_block_bitlen == min_bitlen then\n      CompressDynamicHuffmanBlock(WriteBits, is_last_block, lcodes, lextra_bits,\n                                  dcodes, dextra_bits, HLIT, HDIST, HCLEN,\n                                  rle_codes_huffman_bitlens,\n                                  rle_codes_huffman_codes, rle_deflate_codes,\n                                  rle_extra_bits, lcodes_huffman_bitlens,\n                                  lcodes_huffman_codes, dcodes_huffman_bitlens,\n                                  dcodes_huffman_codes)\n      total_bitlen = total_bitlen + dynamic_block_bitlen\n    end\n\n    if is_last_block then\n      bitlen_written = FlushWriter(_FLUSH_MODE_NO_FLUSH)\n    else\n      bitlen_written = FlushWriter(_FLUSH_MODE_MEMORY_CLEANUP)\n    end\n\n    assert(bitlen_written == total_bitlen)\n\n    -- Memory clean up, so memory consumption does not always grow linearly\n    -- , even if input string is > 64K.\n    -- Not a very efficient operation, but this operation won't happen\n    -- when the input data size is less than 64K.\n    if not is_last_block then\n      local j\n      if dictionary and block_start == 1 then\n        j = 0\n        while (string_table[j]) do\n          string_table[j] = nil\n          j = j - 1\n        end\n      end\n      dictionary = nil\n      j = 1\n      for i = block_end - 32767, block_end do\n        string_table[j] = string_table[i - offset]\n        j = j + 1\n      end\n\n      for k, t in pairs(hash_tables) do\n        local tSize = #t\n        if tSize > 0 and block_end + 1 - t[1] > 32768 then\n          if tSize == 1 then\n            hash_tables[k] = nil\n          else\n            local new = {}\n            local newSize = 0\n            for i = 2, tSize do\n              j = t[i]\n              if block_end + 1 - j <= 32768 then\n                newSize = newSize + 1\n                new[newSize] = j\n              end\n            end\n            hash_tables[k] = new\n          end\n        end\n      end\n    end\n  end\nend\n\n--- The description to compression configuration table. <br>\n-- Any field can be nil to use its default. <br>\n-- Table with keys other than those below is an invalid table.\n-- @class table\n-- @name compression_configs\n-- @field level The compression level ranged from 0 to 9. 0 is no compression.\n-- 9 is the slowest but best compression. Use nil for default level.\n-- @field strategy The compression strategy. \"fixed\" to only use fixed deflate\n-- compression block. \"dynamic\" to only use dynamic block. \"huffman_only\" to\n-- do no LZ77 compression. Only do huffman compression.\n\n-- @see LibDeflate:CompressDeflate(str, configs)\n-- @see LibDeflate:CompressDeflateWithDict(str, dictionary, configs)\nlocal function CompressDeflateInternal(str, dictionary, configs)\n  local WriteBits, WriteString, FlushWriter = CreateWriter()\n  Deflate(configs, WriteBits, WriteString, FlushWriter, str, dictionary)\n  local total_bitlen, result = FlushWriter(_FLUSH_MODE_OUTPUT)\n  local padding_bitlen = (8 - total_bitlen % 8) % 8\n  return result, padding_bitlen\nend\n\n-- @see LibDeflate:CompressZlib\n-- @see LibDeflate:CompressZlibWithDict\nlocal function CompressZlibInternal(str, dictionary, configs)\n  local WriteBits, WriteString, FlushWriter = CreateWriter()\n\n  local CM = 8 -- Compression method\n  local CINFO = 7 -- Window Size = 32K\n  local CMF = CINFO * 16 + CM\n  WriteBits(CMF, 8)\n\n  local FDIST = dictionary and 1 or 0\n  local FLEVEL = 2 -- Default compression\n  local FLG = FLEVEL * 64 + FDIST * 32\n  local FCHECK = (31 - (CMF * 256 + FLG) % 31)\n  -- The FCHECK value must be such that CMF and FLG,\n  -- when viewed as a 16-bit unsigned integer stored\n  -- in MSB order (CMF*256 + FLG), is a multiple of 31.\n  FLG = FLG + FCHECK\n  WriteBits(FLG, 8)\n\n  if FDIST == 1 then\n    local adler32 = dictionary.adler32\n    local byte0 = adler32 % 256\n    adler32 = (adler32 - byte0) / 256\n    local byte1 = adler32 % 256\n    adler32 = (adler32 - byte1) / 256\n    local byte2 = adler32 % 256\n    adler32 = (adler32 - byte2) / 256\n    local byte3 = adler32 % 256\n    WriteBits(byte3, 8)\n    WriteBits(byte2, 8)\n    WriteBits(byte1, 8)\n    WriteBits(byte0, 8)\n  end\n\n  Deflate(configs, WriteBits, WriteString, FlushWriter, str, dictionary)\n  FlushWriter(_FLUSH_MODE_BYTE_BOUNDARY)\n\n  local adler32 = LibDeflate:Adler32(str)\n\n  -- Most significant byte first\n  local byte3 = adler32 % 256\n  adler32 = (adler32 - byte3) / 256\n  local byte2 = adler32 % 256\n  adler32 = (adler32 - byte2) / 256\n  local byte1 = adler32 % 256\n  adler32 = (adler32 - byte1) / 256\n  local byte0 = adler32 % 256\n\n  WriteBits(byte0, 8)\n  WriteBits(byte1, 8)\n  WriteBits(byte2, 8)\n  WriteBits(byte3, 8)\n  local total_bitlen, result = FlushWriter(_FLUSH_MODE_OUTPUT)\n  local padding_bitlen = (8 - total_bitlen % 8) % 8\n  return result, padding_bitlen\nend\n\n--- Compress using the raw deflate format.\n-- @param str [string] The data to be compressed.\n-- @param configs [table/nil] The configuration table to control the compression\n-- . If nil, use the default configuration.\n-- @return [string] The compressed data.\n-- @return [integer] The number of bits padded at the end of output.\n-- 0 <= bits < 8  <br>\n-- This means the most significant \"bits\" of the last byte of the returned\n-- compressed data are padding bits and they don't affect decompression.\n-- You don't need to use this value unless you want to do some postprocessing\n-- to the compressed data.\n-- @see compression_configs\n-- @see LibDeflate:DecompressDeflate\nfunction LibDeflate:CompressDeflate(str, configs)\n  local arg_valid, arg_err = IsValidArguments(str, false, nil, true, configs)\n  if not arg_valid then\n    error((\"Usage: LibDeflate:CompressDeflate(str, configs): \" .. arg_err), 2)\n  end\n  return CompressDeflateInternal(str, nil, configs)\nend\n\n--- Compress using the raw deflate format with a preset dictionary.\n-- @param str [string] The data to be compressed.\n-- @param dictionary [table] The preset dictionary produced by\n-- LibDeflate:CreateDictionary\n-- @param configs [table/nil] The configuration table to control the compression\n-- . If nil, use the default configuration.\n-- @return [string] The compressed data.\n-- @return [integer] The number of bits padded at the end of output.\n-- 0 <= bits < 8  <br>\n-- This means the most significant \"bits\" of the last byte of the returned\n-- compressed data are padding bits and they don't affect decompression.\n-- You don't need to use this value unless you want to do some postprocessing\n-- to the compressed data.\n-- @see compression_configs\n-- @see LibDeflate:CreateDictionary\n-- @see LibDeflate:DecompressDeflateWithDict\nfunction LibDeflate:CompressDeflateWithDict(str, dictionary, configs)\n  local arg_valid, arg_err = IsValidArguments(str, true, dictionary, true,\n                                              configs)\n  if not arg_valid then\n    error((\"Usage: LibDeflate:CompressDeflateWithDict\" ..\n            \"(str, dictionary, configs): \" .. arg_err), 2)\n  end\n  return CompressDeflateInternal(str, dictionary, configs)\nend\n\n--- Compress using the zlib format.\n-- @param str [string] the data to be compressed.\n-- @param configs [table/nil] The configuration table to control the compression\n-- . If nil, use the default configuration.\n-- @return [string] The compressed data.\n-- @return [integer] The number of bits padded at the end of output.\n-- Should always be 0.\n-- Zlib formatted compressed data never has padding bits at the end.\n-- @see compression_configs\n-- @see LibDeflate:DecompressZlib\nfunction LibDeflate:CompressZlib(str, configs)\n  local arg_valid, arg_err = IsValidArguments(str, false, nil, true, configs)\n  if not arg_valid then\n    error((\"Usage: LibDeflate:CompressZlib(str, configs): \" .. arg_err), 2)\n  end\n  return CompressZlibInternal(str, nil, configs)\nend\n\n--- Compress using the zlib format with a preset dictionary.\n-- @param str [string] the data to be compressed.\n-- @param dictionary [table] A preset dictionary produced\n-- by LibDeflate:CreateDictionary()\n-- @param configs [table/nil] The configuration table to control the compression\n-- . If nil, use the default configuration.\n-- @return [string] The compressed data.\n-- @return [integer] The number of bits padded at the end of output.\n-- Should always be 0.\n-- Zlib formatted compressed data never has padding bits at the end.\n-- @see compression_configs\n-- @see LibDeflate:CreateDictionary\n-- @see LibDeflate:DecompressZlibWithDict\nfunction LibDeflate:CompressZlibWithDict(str, dictionary, configs)\n  local arg_valid, arg_err = IsValidArguments(str, true, dictionary, true,\n                                              configs)\n  if not arg_valid then\n    error((\"Usage: LibDeflate:CompressZlibWithDict\" ..\n            \"(str, dictionary, configs): \" .. arg_err), 2)\n  end\n  return CompressZlibInternal(str, dictionary, configs)\nend\n\n--[[ --------------------------------------------------------------------------\n	Decompress code\n--]] --------------------------------------------------------------------------\n\n--[[\n	Create a reader to easily reader stuffs as the unit of bits.\n	Return values:\n	1. ReadBits(bitlen)\n	2. ReadBytes(bytelen, buffer, buffer_size)\n	3. Decode(huffman_bitlen_count, huffman_symbol, min_bitlen)\n	4. ReaderBitlenLeft()\n	5. SkipToByteBoundary()\n--]]\nlocal function CreateReader(input_string)\n  local input = input_string\n  local input_strlen = #input_string\n  local input_next_byte_pos = 1\n  local cache_bitlen = 0\n  local cache = 0\n\n  -- Read some bits.\n  -- To improve speed, this function does not\n  -- check if the input has been exhausted.\n  -- Use ReaderBitlenLeft() < 0 to check it.\n  -- @param bitlen the number of bits to read\n  -- @return the data is read.\n  local function ReadBits(bitlen)\n    local rshift_mask = _pow2[bitlen]\n    local code\n    if bitlen <= cache_bitlen then\n      code = cache % rshift_mask\n      cache = (cache - code) / rshift_mask\n      cache_bitlen = cache_bitlen - bitlen\n    else -- Whether input has been exhausted is not checked.\n      local lshift_mask = _pow2[cache_bitlen]\n      local byte1, byte2, byte3, byte4 =\n        string_byte(input, input_next_byte_pos, input_next_byte_pos + 3)\n      -- This requires lua number to be at least double ()\n      cache = cache +\n                ((byte1 or 0) + (byte2 or 0) * 256 + (byte3 or 0) * 65536 +\n                  (byte4 or 0) * 16777216) * lshift_mask\n      input_next_byte_pos = input_next_byte_pos + 4\n      cache_bitlen = cache_bitlen + 32 - bitlen\n      code = cache % rshift_mask\n      cache = (cache - code) / rshift_mask\n    end\n    return code\n  end\n\n  -- Read some bytes from the reader.\n  -- Assume reader is on the byte boundary.\n  -- @param bytelen The number of bytes to be read.\n  -- @param buffer The byte read will be stored into this buffer.\n  -- @param buffer_size The buffer will be modified starting from\n  --	buffer[buffer_size+1], ending at buffer[buffer_size+bytelen-1]\n  -- @return the new buffer_size\n  local function ReadBytes(bytelen, buffer, buffer_size)\n    assert(cache_bitlen % 8 == 0)\n\n    local byte_from_cache =\n      (cache_bitlen / 8 < bytelen) and (cache_bitlen / 8) or bytelen\n    for _ = 1, byte_from_cache do\n      local byte = cache % 256\n      buffer_size = buffer_size + 1\n      buffer[buffer_size] = string_char(byte)\n      cache = (cache - byte) / 256\n    end\n    cache_bitlen = cache_bitlen - byte_from_cache * 8\n    bytelen = bytelen - byte_from_cache\n    if (input_strlen - input_next_byte_pos - bytelen + 1) * 8 + cache_bitlen < 0 then\n      return -1 -- out of input\n    end\n    for i = input_next_byte_pos, input_next_byte_pos + bytelen - 1 do\n      buffer_size = buffer_size + 1\n      buffer[buffer_size] = string_sub(input, i, i)\n    end\n\n    input_next_byte_pos = input_next_byte_pos + bytelen\n    return buffer_size\n  end\n\n  -- Decode huffman code\n  -- To improve speed, this function does not check\n  -- if the input has been exhausted.\n  -- Use ReaderBitlenLeft() < 0 to check it.\n  -- Credits for Mark Adler. This code is from puff:Decode()\n  -- @see puff:Decode(...)\n  -- @param huffman_bitlen_count\n  -- @param huffman_symbol\n  -- @param min_bitlen The minimum huffman bit length of all symbols\n  -- @return The decoded deflate code.\n  --	Negative value is returned if decoding fails.\n  local function Decode(huffman_bitlen_counts, huffman_symbols, min_bitlen)\n    local code = 0\n    local first = 0\n    local index = 0\n    local count\n    if min_bitlen > 0 then\n      if cache_bitlen < 15 and input then\n        local lshift_mask = _pow2[cache_bitlen]\n        local byte1, byte2, byte3, byte4 =\n          string_byte(input, input_next_byte_pos, input_next_byte_pos + 3)\n        -- This requires lua number to be at least double ()\n        cache = cache +\n                  ((byte1 or 0) + (byte2 or 0) * 256 + (byte3 or 0) * 65536 +\n                    (byte4 or 0) * 16777216) * lshift_mask\n        input_next_byte_pos = input_next_byte_pos + 4\n        cache_bitlen = cache_bitlen + 32\n      end\n\n      local rshift_mask = _pow2[min_bitlen]\n      cache_bitlen = cache_bitlen - min_bitlen\n      code = cache % rshift_mask\n      cache = (cache - code) / rshift_mask\n      -- Reverse the bits\n      code = _reverse_bits_tbl[min_bitlen][code]\n\n      count = huffman_bitlen_counts[min_bitlen]\n      if code < count then return huffman_symbols[code] end\n      index = count\n      first = count * 2\n      code = code * 2\n    end\n\n    for bitlen = min_bitlen + 1, 15 do\n      local bit\n      bit = cache % 2\n      cache = (cache - bit) / 2\n      cache_bitlen = cache_bitlen - 1\n\n      code = (bit == 1) and (code + 1 - code % 2) or code\n      count = huffman_bitlen_counts[bitlen] or 0\n      local diff = code - first\n      if diff < count then return huffman_symbols[index + diff] end\n      index = index + count\n      first = first + count\n      first = first * 2\n      code = code * 2\n    end\n    -- invalid literal/length or distance code\n    -- in fixed or dynamic block (run out of code)\n    return -10\n  end\n\n  local function ReaderBitlenLeft()\n    return (input_strlen - input_next_byte_pos + 1) * 8 + cache_bitlen\n  end\n\n  local function SkipToByteBoundary()\n    local skipped_bitlen = cache_bitlen % 8\n    local rshift_mask = _pow2[skipped_bitlen]\n    cache_bitlen = cache_bitlen - skipped_bitlen\n    cache = (cache - cache % rshift_mask) / rshift_mask\n  end\n\n  return ReadBits, ReadBytes, Decode, ReaderBitlenLeft, SkipToByteBoundary\nend\n\n-- Create a deflate state, so I can pass in less arguments to functions.\n-- @param str the whole string to be decompressed.\n-- @param dictionary The preset dictionary. nil if not provided.\n--		This dictionary should be produced by LibDeflate:CreateDictionary(str)\n-- @return The decomrpess state.\nlocal function CreateDecompressState(str, dictionary)\n  local ReadBits, ReadBytes, Decode, ReaderBitlenLeft, SkipToByteBoundary =\n    CreateReader(str)\n  local state = {\n    ReadBits = ReadBits,\n    ReadBytes = ReadBytes,\n    Decode = Decode,\n    ReaderBitlenLeft = ReaderBitlenLeft,\n    SkipToByteBoundary = SkipToByteBoundary,\n    buffer_size = 0,\n    buffer = {},\n    result_buffer = {},\n    dictionary = dictionary\n  }\n  return state\nend\n\n-- Get the stuffs needed to decode huffman codes\n-- @see puff.c:construct(...)\n-- @param huffman_bitlen The huffman bit length of the huffman codes.\n-- @param max_symbol The maximum symbol\n-- @param max_bitlen The min huffman bit length of all codes\n-- @return zero or positive for success, negative for failure.\n-- @return The count of each huffman bit length.\n-- @return A table to convert huffman codes to deflate codes.\n-- @return The minimum huffman bit length.\nlocal function GetHuffmanForDecode(huffman_bitlens, max_symbol, max_bitlen)\n  local huffman_bitlen_counts = {}\n  local min_bitlen = max_bitlen\n  for symbol = 0, max_symbol do\n    local bitlen = huffman_bitlens[symbol] or 0\n    min_bitlen = (bitlen > 0 and bitlen < min_bitlen) and bitlen or min_bitlen\n    huffman_bitlen_counts[bitlen] = (huffman_bitlen_counts[bitlen] or 0) + 1\n  end\n\n  if huffman_bitlen_counts[0] == max_symbol + 1 then -- No Codes\n    return 0, huffman_bitlen_counts, {}, 0 -- Complete, but decode will fail\n  end\n\n  local left = 1\n  for len = 1, max_bitlen do\n    left = left * 2\n    left = left - (huffman_bitlen_counts[len] or 0)\n    if left < 0 then\n      return left -- Over-subscribed, return negative\n    end\n  end\n\n  -- Generate offsets info symbol table for each length for sorting\n  local offsets = {}\n  offsets[1] = 0\n  for len = 1, max_bitlen - 1 do\n    offsets[len + 1] = offsets[len] + (huffman_bitlen_counts[len] or 0)\n  end\n\n  local huffman_symbols = {}\n  for symbol = 0, max_symbol do\n    local bitlen = huffman_bitlens[symbol] or 0\n    if bitlen ~= 0 then\n      local offset = offsets[bitlen]\n      huffman_symbols[offset] = symbol\n      offsets[bitlen] = offsets[bitlen] + 1\n    end\n  end\n\n  -- Return zero for complete set, positive for incomplete set.\n  return left, huffman_bitlen_counts, huffman_symbols, min_bitlen\nend\n\n-- Decode a fixed or dynamic huffman blocks, excluding last block identifier\n-- and block type identifer.\n-- @see puff.c:codes()\n-- @param state decompression state that will be modified by this function.\n--	@see CreateDecompressState\n-- @param ... Read the source code\n-- @return 0 on success, other value on failure.\nlocal function DecodeUntilEndOfBlock(state, lcodes_huffman_bitlens,\n                                     lcodes_huffman_symbols,\n                                     lcodes_huffman_min_bitlen,\n                                     dcodes_huffman_bitlens,\n                                     dcodes_huffman_symbols,\n                                     dcodes_huffman_min_bitlen)\n  local buffer, buffer_size, ReadBits, Decode, ReaderBitlenLeft, result_buffer =\n    state.buffer, state.buffer_size, state.ReadBits, state.Decode,\n    state.ReaderBitlenLeft, state.result_buffer\n  local dictionary = state.dictionary\n  local dict_string_table\n  local dict_strlen\n\n  local buffer_end = 1\n  if dictionary and not buffer[0] then\n    -- If there is a dictionary, copy the last 258 bytes into\n    -- the string_table to make the copy in the main loop quicker.\n    -- This is done only once per decompression.\n    dict_string_table = dictionary.string_table\n    dict_strlen = dictionary.strlen\n    buffer_end = -dict_strlen + 1\n    for i = 0, (-dict_strlen + 1) < -257 and -257 or (-dict_strlen + 1), -1 do\n      buffer[i] = _byte_to_char[dict_string_table[dict_strlen + i]]\n    end\n  end\n\n  repeat\n    local symbol = Decode(lcodes_huffman_bitlens, lcodes_huffman_symbols,\n                          lcodes_huffman_min_bitlen)\n    if symbol < 0 or symbol > 285 then\n      -- invalid literal/length or distance code in fixed or dynamic block\n      return -10\n    elseif symbol < 256 then -- Literal\n      buffer_size = buffer_size + 1\n      buffer[buffer_size] = _byte_to_char[symbol]\n    elseif symbol > 256 then -- Length code\n      symbol = symbol - 256\n      local bitlen = _literal_deflate_code_to_base_len[symbol]\n      bitlen = (symbol >= 8) and\n                 (bitlen +\n                   ReadBits(_literal_deflate_code_to_extra_bitlen[symbol])) or\n                 bitlen\n      symbol = Decode(dcodes_huffman_bitlens, dcodes_huffman_symbols,\n                      dcodes_huffman_min_bitlen)\n      if symbol < 0 or symbol > 29 then\n        -- invalid literal/length or distance code in fixed or dynamic block\n        return -10\n      end\n      local dist = _dist_deflate_code_to_base_dist[symbol]\n      dist = (dist > 4) and\n               (dist + ReadBits(_dist_deflate_code_to_extra_bitlen[symbol])) or\n               dist\n\n      local char_buffer_index = buffer_size - dist + 1\n      if char_buffer_index < buffer_end then\n        -- distance is too far back in fixed or dynamic block\n        return -11\n      end\n      if char_buffer_index >= -257 then\n        for _ = 1, bitlen do\n          buffer_size = buffer_size + 1\n          buffer[buffer_size] = buffer[char_buffer_index]\n          char_buffer_index = char_buffer_index + 1\n        end\n      else\n        char_buffer_index = dict_strlen + char_buffer_index\n        for _ = 1, bitlen do\n          buffer_size = buffer_size + 1\n          buffer[buffer_size] =\n            _byte_to_char[dict_string_table[char_buffer_index]]\n          char_buffer_index = char_buffer_index + 1\n        end\n      end\n    end\n\n    if ReaderBitlenLeft() < 0 then\n      return 2 -- available inflate data did not terminate\n    end\n\n    if buffer_size >= 65536 then\n      result_buffer[#result_buffer + 1] = table_concat(buffer, \"\", 1, 32768)\n      for i = 32769, buffer_size do buffer[i - 32768] = buffer[i] end\n      buffer_size = buffer_size - 32768\n      buffer[buffer_size + 1] = nil\n      -- NOTE: buffer[32769..end] and buffer[-257..0] are not cleared.\n      -- This is why \"buffer_size\" variable is needed.\n    end\n  until symbol == 256\n\n  state.buffer_size = buffer_size\n\n  return 0\nend\n\n-- Decompress a store block\n-- @param state decompression state that will be modified by this function.\n-- @return 0 if succeeds, other value if fails.\nlocal function DecompressStoreBlock(state)\n  local buffer, buffer_size, ReadBits, ReadBytes, ReaderBitlenLeft,\n        SkipToByteBoundary, result_buffer = state.buffer, state.buffer_size,\n                                            state.ReadBits, state.ReadBytes,\n                                            state.ReaderBitlenLeft,\n                                            state.SkipToByteBoundary,\n                                            state.result_buffer\n\n  SkipToByteBoundary()\n  local bytelen = ReadBits(16)\n  if ReaderBitlenLeft() < 0 then\n    return 2 -- available inflate data did not terminate\n  end\n  local bytelenComp = ReadBits(16)\n  if ReaderBitlenLeft() < 0 then\n    return 2 -- available inflate data did not terminate\n  end\n\n  if bytelen % 256 + bytelenComp % 256 ~= 255 then\n    return -2 -- Not one's complement\n  end\n  if (bytelen - bytelen % 256) / 256 + (bytelenComp - bytelenComp % 256) / 256 ~=\n    255 then\n    return -2 -- Not one's complement\n  end\n\n  -- Note that ReadBytes will skip to the next byte boundary first.\n  buffer_size = ReadBytes(bytelen, buffer, buffer_size)\n  if buffer_size < 0 then\n    return 2 -- available inflate data did not terminate\n  end\n\n  -- memory clean up when there are enough bytes in the buffer.\n  if buffer_size >= 65536 then\n    result_buffer[#result_buffer + 1] = table_concat(buffer, \"\", 1, 32768)\n    for i = 32769, buffer_size do buffer[i - 32768] = buffer[i] end\n    buffer_size = buffer_size - 32768\n    buffer[buffer_size + 1] = nil\n  end\n  state.buffer_size = buffer_size\n  return 0\nend\n\n-- Decompress a fixed block\n-- @param state decompression state that will be modified by this function.\n-- @return 0 if succeeds other value if fails.\nlocal function DecompressFixBlock(state)\n  return DecodeUntilEndOfBlock(state, _fix_block_literal_huffman_bitlen_count,\n                               _fix_block_literal_huffman_to_deflate_code, 7,\n                               _fix_block_dist_huffman_bitlen_count,\n                               _fix_block_dist_huffman_to_deflate_code, 5)\nend\n\n-- Decompress a dynamic block\n-- @param state decompression state that will be modified by this function.\n-- @return 0 if success, other value if fails.\nlocal function DecompressDynamicBlock(state)\n  local ReadBits, Decode = state.ReadBits, state.Decode\n  local nlen = ReadBits(5) + 257\n  local ndist = ReadBits(5) + 1\n  local ncode = ReadBits(4) + 4\n  if nlen > 286 or ndist > 30 then\n    -- dynamic block code description: too many length or distance codes\n    return -3\n  end\n\n  local rle_codes_huffman_bitlens = {}\n\n  for i = 1, ncode do\n    rle_codes_huffman_bitlens[_rle_codes_huffman_bitlen_order[i]] = ReadBits(3)\n  end\n\n  local rle_codes_err, rle_codes_huffman_bitlen_counts,\n        rle_codes_huffman_symbols, rle_codes_huffman_min_bitlen =\n    GetHuffmanForDecode(rle_codes_huffman_bitlens, 18, 7)\n  if rle_codes_err ~= 0 then -- Require complete code set here\n    -- dynamic block code description: code lengths codes incomplete\n    return -4\n  end\n\n  local lcodes_huffman_bitlens = {}\n  local dcodes_huffman_bitlens = {}\n  -- Read length/literal and distance code length tables\n  local index = 0\n  while index < nlen + ndist do\n    local symbol -- Decoded value\n    local bitlen -- Last length to repeat\n\n    symbol = Decode(rle_codes_huffman_bitlen_counts, rle_codes_huffman_symbols,\n                    rle_codes_huffman_min_bitlen)\n\n    if symbol < 0 then\n      return symbol -- Invalid symbol\n    elseif symbol < 16 then\n      if index < nlen then\n        lcodes_huffman_bitlens[index] = symbol\n      else\n        dcodes_huffman_bitlens[index - nlen] = symbol\n      end\n      index = index + 1\n    else\n      bitlen = 0\n      if symbol == 16 then\n        if index == 0 then\n          -- dynamic block code description: repeat lengths\n          -- with no first length\n          return -5\n        end\n        if index - 1 < nlen then\n          bitlen = lcodes_huffman_bitlens[index - 1]\n        else\n          bitlen = dcodes_huffman_bitlens[index - nlen - 1]\n        end\n        symbol = 3 + ReadBits(2)\n      elseif symbol == 17 then -- Repeat zero 3..10 times\n        symbol = 3 + ReadBits(3)\n      else -- == 18, repeat zero 11.138 times\n        symbol = 11 + ReadBits(7)\n      end\n      if index + symbol > nlen + ndist then\n        -- dynamic block code description:\n        -- repeat more than specified lengths\n        return -6\n      end\n      while symbol > 0 do -- Repeat last or zero symbol times\n        symbol = symbol - 1\n        if index < nlen then\n          lcodes_huffman_bitlens[index] = bitlen\n        else\n          dcodes_huffman_bitlens[index - nlen] = bitlen\n        end\n        index = index + 1\n      end\n    end\n  end\n\n  if (lcodes_huffman_bitlens[256] or 0) == 0 then\n    -- dynamic block code description: missing end-of-block code\n    return -9\n  end\n\n  local lcodes_err, lcodes_huffman_bitlen_counts, lcodes_huffman_symbols,\n        lcodes_huffman_min_bitlen = GetHuffmanForDecode(lcodes_huffman_bitlens,\n                                                        nlen - 1, 15)\n  -- dynamic block code description: invalid literal/length code lengths,\n  -- Incomplete code ok only for single length 1 code\n  if (lcodes_err ~= 0 and\n    (lcodes_err < 0 or nlen ~= (lcodes_huffman_bitlen_counts[0] or 0) +\n      (lcodes_huffman_bitlen_counts[1] or 0))) then return -7 end\n\n  local dcodes_err, dcodes_huffman_bitlen_counts, dcodes_huffman_symbols,\n        dcodes_huffman_min_bitlen = GetHuffmanForDecode(dcodes_huffman_bitlens,\n                                                        ndist - 1, 15)\n  -- dynamic block code description: invalid distance code lengths,\n  -- Incomplete code ok only for single length 1 code\n  if (dcodes_err ~= 0 and\n    (dcodes_err < 0 or ndist ~= (dcodes_huffman_bitlen_counts[0] or 0) +\n      (dcodes_huffman_bitlen_counts[1] or 0))) then return -8 end\n\n  -- Build buffman table for literal/length codes\n  return DecodeUntilEndOfBlock(state, lcodes_huffman_bitlen_counts,\n                               lcodes_huffman_symbols,\n                               lcodes_huffman_min_bitlen,\n                               dcodes_huffman_bitlen_counts,\n                               dcodes_huffman_symbols, dcodes_huffman_min_bitlen)\nend\n\n-- Decompress a deflate stream\n-- @param state: a decompression state\n-- @return the decompressed string if succeeds. nil if fails.\nlocal function Inflate(state)\n  local ReadBits = state.ReadBits\n\n  local is_last_block\n  while not is_last_block do\n    is_last_block = (ReadBits(1) == 1)\n    local block_type = ReadBits(2)\n    local status\n    if block_type == 0 then\n      status = DecompressStoreBlock(state)\n    elseif block_type == 1 then\n      status = DecompressFixBlock(state)\n    elseif block_type == 2 then\n      status = DecompressDynamicBlock(state)\n    else\n      return nil, -1 -- invalid block type (type == 3)\n    end\n    if status ~= 0 then return nil, status end\n  end\n\n  state.result_buffer[#state.result_buffer + 1] =\n    table_concat(state.buffer, \"\", 1, state.buffer_size)\n  local result = table_concat(state.result_buffer)\n  return result\nend\n\n-- @see LibDeflate:DecompressDeflate(str)\n-- @see LibDeflate:DecompressDeflateWithDict(str, dictionary)\nlocal function DecompressDeflateInternal(str, dictionary)\n  local state = CreateDecompressState(str, dictionary)\n  local result, status = Inflate(state)\n  if not result then return nil, status end\n\n  local bitlen_left = state.ReaderBitlenLeft()\n  local bytelen_left = (bitlen_left - bitlen_left % 8) / 8\n  return result, bytelen_left\nend\n\n-- @see LibDeflate:DecompressZlib(str)\n-- @see LibDeflate:DecompressZlibWithDict(str)\nlocal function DecompressZlibInternal(str, dictionary)\n  local state = CreateDecompressState(str, dictionary)\n  local ReadBits = state.ReadBits\n\n  local CMF = ReadBits(8)\n  if state.ReaderBitlenLeft() < 0 then\n    return nil, 2 -- available inflate data did not terminate\n  end\n  local CM = CMF % 16\n  local CINFO = (CMF - CM) / 16\n  if CM ~= 8 then\n    return nil, -12 -- invalid compression method\n  end\n  if CINFO > 7 then\n    return nil, -13 -- invalid window size\n  end\n\n  local FLG = ReadBits(8)\n  if state.ReaderBitlenLeft() < 0 then\n    return nil, 2 -- available inflate data did not terminate\n  end\n  if (CMF * 256 + FLG) % 31 ~= 0 then\n    return nil, -14 -- invalid header checksum\n  end\n\n  local FDIST = ((FLG - FLG % 32) / 32 % 2)\n  local FLEVEL = ((FLG - FLG % 64) / 64 % 4) -- luacheck: ignore FLEVEL\n\n  if FDIST == 1 then\n    if not dictionary then\n      return nil, -16 -- need dictonary, but dictionary is not provided.\n    end\n    local byte3 = ReadBits(8)\n    local byte2 = ReadBits(8)\n    local byte1 = ReadBits(8)\n    local byte0 = ReadBits(8)\n    local actual_adler32 = byte3 * 16777216 + byte2 * 65536 + byte1 * 256 +\n                             byte0\n    if state.ReaderBitlenLeft() < 0 then\n      return nil, 2 -- available inflate data did not terminate\n    end\n    if not IsEqualAdler32(actual_adler32, dictionary.adler32) then\n      return nil, -17 -- dictionary adler32 does not match\n    end\n  end\n  local result, status = Inflate(state)\n  if not result then return nil, status end\n  state.SkipToByteBoundary()\n\n  local adler_byte0 = ReadBits(8)\n  local adler_byte1 = ReadBits(8)\n  local adler_byte2 = ReadBits(8)\n  local adler_byte3 = ReadBits(8)\n  if state.ReaderBitlenLeft() < 0 then\n    return nil, 2 -- available inflate data did not terminate\n  end\n\n  local adler32_expected = adler_byte0 * 16777216 + adler_byte1 * 65536 +\n                             adler_byte2 * 256 + adler_byte3\n  local adler32_actual = LibDeflate:Adler32(result)\n  if not IsEqualAdler32(adler32_expected, adler32_actual) then\n    return nil, -15 -- Adler32 checksum does not match\n  end\n\n  local bitlen_left = state.ReaderBitlenLeft()\n  local bytelen_left = (bitlen_left - bitlen_left % 8) / 8\n  return result, bytelen_left\nend\n\n--- Decompress a raw deflate compressed data.\n-- @param str [string] The data to be decompressed.\n-- @return [string/nil] If the decompression succeeds, return the decompressed\n-- data. If the decompression fails, return nil. You should check if this return\n-- value is non-nil to know if the decompression succeeds.\n-- @return [integer] If the decompression succeeds, return the number of\n-- unprocessed bytes in the input compressed data. This return value is a\n-- positive integer if the input data is a valid compressed data appended by an\n-- arbitary non-empty string. This return value is 0 if the input data does not\n-- contain any extra bytes.<br>\n-- If the decompression fails (The first return value of this function is nil),\n-- this return value is undefined.\n-- @see LibDeflate:CompressDeflate\nfunction LibDeflate:DecompressDeflate(str)\n  local arg_valid, arg_err = IsValidArguments(str)\n  if not arg_valid then\n    error((\"Usage: LibDeflate:DecompressDeflate(str): \" .. arg_err), 2)\n  end\n  return DecompressDeflateInternal(str)\nend\n\n--- Decompress a raw deflate compressed data with a preset dictionary.\n-- @param str [string] The data to be decompressed.\n-- @param dictionary [table] The preset dictionary used by\n-- LibDeflate:CompressDeflateWithDict when the compressed data is produced.\n-- Decompression and compression must use the same dictionary.\n-- Otherwise wrong decompressed data could be produced without generating any\n-- error.\n-- @return [string/nil] If the decompression succeeds, return the decompressed\n-- data. If the decompression fails, return nil. You should check if this return\n-- value is non-nil to know if the decompression succeeds.\n-- @return [integer] If the decompression succeeds, return the number of\n-- unprocessed bytes in the input compressed data. This return value is a\n-- positive integer if the input data is a valid compressed data appended by an\n-- arbitary non-empty string. This return value is 0 if the input data does not\n-- contain any extra bytes.<br>\n-- If the decompression fails (The first return value of this function is nil),\n-- this return value is undefined.\n-- @see LibDeflate:CompressDeflateWithDict\nfunction LibDeflate:DecompressDeflateWithDict(str, dictionary)\n  local arg_valid, arg_err = IsValidArguments(str, true, dictionary)\n  if not arg_valid then\n    error((\"Usage: LibDeflate:DecompressDeflateWithDict(str, dictionary): \" ..\n            arg_err), 2)\n  end\n  return DecompressDeflateInternal(str, dictionary)\nend\n\n--- Decompress a zlib compressed data.\n-- @param str [string] The data to be decompressed\n-- @return [string/nil] If the decompression succeeds, return the decompressed\n-- data. If the decompression fails, return nil. You should check if this return\n-- value is non-nil to know if the decompression succeeds.\n-- @return [integer] If the decompression succeeds, return the number of\n-- unprocessed bytes in the input compressed data. This return value is a\n-- positive integer if the input data is a valid compressed data appended by an\n-- arbitary non-empty string. This return value is 0 if the input data does not\n-- contain any extra bytes.<br>\n-- If the decompression fails (The first return value of this function is nil),\n-- this return value is undefined.\n-- @see LibDeflate:CompressZlib\nfunction LibDeflate:DecompressZlib(str)\n  local arg_valid, arg_err = IsValidArguments(str)\n  if not arg_valid then\n    error((\"Usage: LibDeflate:DecompressZlib(str): \" .. arg_err), 2)\n  end\n  return DecompressZlibInternal(str)\nend\n\n--- Decompress a zlib compressed data with a preset dictionary.\n-- @param str [string] The data to be decompressed\n-- @param dictionary [table] The preset dictionary used by\n-- LibDeflate:CompressDeflateWithDict when the compressed data is produced.\n-- Decompression and compression must use the same dictionary.\n-- Otherwise wrong decompressed data could be produced without generating any\n-- error.\n-- @return [string/nil] If the decompression succeeds, return the decompressed\n-- data. If the decompression fails, return nil. You should check if this return\n-- value is non-nil to know if the decompression succeeds.\n-- @return [integer] If the decompression succeeds, return the number of\n-- unprocessed bytes in the input compressed data. This return value is a\n-- positive integer if the input data is a valid compressed data appended by an\n-- arbitary non-empty string. This return value is 0 if the input data does not\n-- contain any extra bytes.<br>\n-- If the decompression fails (The first return value of this function is nil),\n-- this return value is undefined.\n-- @see LibDeflate:CompressZlibWithDict\nfunction LibDeflate:DecompressZlibWithDict(str, dictionary)\n  local arg_valid, arg_err = IsValidArguments(str, true, dictionary)\n  if not arg_valid then\n    error((\"Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): \" ..\n            arg_err), 2)\n  end\n  return DecompressZlibInternal(str, dictionary)\nend\n\n-- Calculate the huffman code of fixed block\ndo\n  _fix_block_literal_huffman_bitlen = {}\n  for sym = 0, 143 do _fix_block_literal_huffman_bitlen[sym] = 8 end\n  for sym = 144, 255 do _fix_block_literal_huffman_bitlen[sym] = 9 end\n  for sym = 256, 279 do _fix_block_literal_huffman_bitlen[sym] = 7 end\n  for sym = 280, 287 do _fix_block_literal_huffman_bitlen[sym] = 8 end\n\n  _fix_block_dist_huffman_bitlen = {}\n  for dist = 0, 31 do _fix_block_dist_huffman_bitlen[dist] = 5 end\n  local status\n  status, _fix_block_literal_huffman_bitlen_count, _fix_block_literal_huffman_to_deflate_code =\n    GetHuffmanForDecode(_fix_block_literal_huffman_bitlen, 287, 9)\n  assert(status == 0)\n  status, _fix_block_dist_huffman_bitlen_count, _fix_block_dist_huffman_to_deflate_code =\n    GetHuffmanForDecode(_fix_block_dist_huffman_bitlen, 31, 5)\n  assert(status == 0)\n\n  _fix_block_literal_huffman_code = GetHuffmanCodeFromBitlen(\n                                      _fix_block_literal_huffman_bitlen_count,\n                                      _fix_block_literal_huffman_bitlen, 287, 9)\n  _fix_block_dist_huffman_code = GetHuffmanCodeFromBitlen(\n                                   _fix_block_dist_huffman_bitlen_count,\n                                   _fix_block_dist_huffman_bitlen, 31, 5)\nend\n\n-- Prefix encoding algorithm\n-- Credits to LibCompress.\n-- The code has been rewritten by the author of LibDeflate.\n------------------------------------------------------------------------------\n\n-- to be able to match any requested byte value, the search\n-- string must be preprocessed characters to escape with %:\n-- ( ) . % + - * ? [ ] ^ $\n-- \"illegal\" byte values:\n-- 0 is replaces %z\nlocal _gsub_escape_table = {\n  [\"\000\"] = \"%z\",\n  [\"(\"] = \"%(\",\n  [\")\"] = \"%)\",\n  [\".\"] = \"%.\",\n  [\"%\"] = \"%%\",\n  [\"+\"] = \"%+\",\n  [\"-\"] = \"%-\",\n  [\"*\"] = \"%*\",\n  [\"?\"] = \"%?\",\n  [\"[\"] = \"%[\",\n  [\"]\"] = \"%]\",\n  [\"^\"] = \"%^\",\n  [\"$\"] = \"%$\"\n}\n\nlocal function escape_for_gsub(str)\n  return str:gsub(\"([%z%(%)%.%%%+%-%*%?%[%]%^%$])\", _gsub_escape_table)\nend\n\n--- Create a custom codec with encoder and decoder. <br>\n-- This codec is used to convert an input string to make it not contain\n-- some specific bytes.\n-- This created codec and the parameters of this function do NOT take\n-- localization into account. One byte (0-255) in the string is exactly one\n-- character (0-255).\n-- Credits to LibCompress.\n-- The code has been rewritten by the author of LibDeflate. <br>\n-- @param reserved_chars [string] The created encoder will ensure encoded\n-- data does not contain any single character in reserved_chars. This parameter\n-- should be non-empty.\n-- @param escape_chars [string] The escape character(s) used in the created\n-- codec. The codec converts any character included in reserved\_chars /\n-- escape\_chars / map\_chars to (one escape char + one character not in\n-- reserved\_chars / escape\_chars / map\_chars).\n-- You usually only need to provide a length-1 string for this parameter.\n-- Length-2 string is only needed when\n-- reserved\_chars + escape\_chars + map\_chars is longer than 127.\n-- This parameter should be non-empty.\n-- @param map_chars [string] The created encoder will map every\n-- reserved\_chars:sub(i, i) (1 <= i <= #map\_chars) to map\_chars:sub(i, i).\n-- This parameter CAN be empty string.\n-- @return [table/nil] If the codec cannot be created, return nil.<br>\n-- If the codec can be created according to the given\n-- parameters, return the codec, which is a encode/decode table.\n-- The table contains two functions: <br>\n-- t:Encode(str) returns the encoded string. <br>\n-- t:Decode(str) returns the decoded string if succeeds. nil if fails.\n-- @return [nil/string] If the codec is successfully created, return nil.\n-- If not, return a string that describes the reason why the codec cannot be\n-- created.\n-- @usage\n-- -- Create an encoder/decoder that maps all \"\000\" to \"\003\",\n-- -- and escape \"\001\" (and \"\002\" and \"\003\") properly\n-- local codec = LibDeflate:CreateCodec(\"\000\001\", \"\002\", \"\003\")\n--\n-- local encoded = codec:Encode(SOME_STRING)\n-- -- \"encoded\" does not contain \"\000\" or \"\001\"\n-- local decoded = codec:Decode(encoded)\n-- -- assert(decoded == SOME_STRING)\nfunction LibDeflate:CreateCodec(reserved_chars, escape_chars, map_chars)\n  if type(reserved_chars) ~= \"string\" or type(escape_chars) ~= \"string\" or\n    type(map_chars) ~= \"string\" then\n    error(\"Usage: LibDeflate:CreateCodec(reserved_chars,\" ..\n            \" escape_chars, map_chars):\" .. \" All arguments must be string.\", 2)\n  end\n\n  if escape_chars == \"\" then return nil, \"No escape characters supplied.\" end\n  if #reserved_chars < #map_chars then\n    return nil, \"The number of reserved characters must be\" ..\n             \" at least as many as the number of mapped chars.\"\n  end\n  if reserved_chars == \"\" then return nil, \"No characters to encode.\" end\n\n  local encode_bytes = reserved_chars .. escape_chars .. map_chars\n  -- build list of bytes not available as a suffix to a prefix byte\n  local taken = {}\n  for i = 1, #encode_bytes do\n    local byte = string_byte(encode_bytes, i, i)\n    if taken[byte] then\n      return nil, \"There must be no duplicate characters in the\" ..\n               \" concatenation of reserved_chars, escape_chars and\" ..\n               \" map_chars.\"\n    end\n    taken[byte] = true\n  end\n\n  local decode_patterns = {}\n  local decode_repls = {}\n\n  -- the encoding can be a single gsub\n  -- , but the decoding can require multiple gsubs\n  local encode_search = {}\n  local encode_translate = {}\n\n  -- map single byte to single byte\n  if #map_chars > 0 then\n    local decode_search = {}\n    local decode_translate = {}\n    for i = 1, #map_chars do\n      local from = string_sub(reserved_chars, i, i)\n      local to = string_sub(map_chars, i, i)\n      encode_translate[from] = to\n      encode_search[#encode_search + 1] = from\n      decode_translate[to] = from\n      decode_search[#decode_search + 1] = to\n    end\n    decode_patterns[#decode_patterns + 1] =\n      \"([\" .. escape_for_gsub(table_concat(decode_search)) .. \"])\"\n    decode_repls[#decode_repls + 1] = decode_translate\n  end\n\n  local escape_char_index = 1\n  local escape_char = string_sub(escape_chars, escape_char_index,\n                                 escape_char_index)\n  -- map single byte to double-byte\n  local r = 0 -- suffix char value to the escapeChar\n\n  local decode_search = {}\n  local decode_translate = {}\n  for i = 1, #encode_bytes do\n    local c = string_sub(encode_bytes, i, i)\n    if not encode_translate[c] then\n      while r >= 256 or taken[r] do\n        r = r + 1\n        if r > 255 then -- switch to next escapeChar\n          decode_patterns[#decode_patterns + 1] =\n            escape_for_gsub(escape_char) .. \"([\" ..\n              escape_for_gsub(table_concat(decode_search)) .. \"])\"\n          decode_repls[#decode_repls + 1] = decode_translate\n\n          escape_char_index = escape_char_index + 1\n          escape_char = string_sub(escape_chars, escape_char_index,\n                                   escape_char_index)\n          r = 0\n          decode_search = {}\n          decode_translate = {}\n\n          if not escape_char or escape_char == \"\" then\n            -- actually I don't need to check\n            -- \"not ecape_char\", but what if Lua changes\n            -- the behavior of string.sub() in the future?\n            -- we are out of escape chars and we need more!\n            return nil, \"Out of escape characters.\"\n          end\n        end\n      end\n\n      local char_r = _byte_to_char[r]\n      encode_translate[c] = escape_char .. char_r\n      encode_search[#encode_search + 1] = c\n      decode_translate[char_r] = c\n      decode_search[#decode_search + 1] = char_r\n      r = r + 1\n    end\n    if i == #encode_bytes then\n      decode_patterns[#decode_patterns + 1] =\n        escape_for_gsub(escape_char) .. \"([\" ..\n          escape_for_gsub(table_concat(decode_search)) .. \"])\"\n      decode_repls[#decode_repls + 1] = decode_translate\n    end\n  end\n\n  local codec = {}\n\n  local encode_pattern = \"([\" .. escape_for_gsub(table_concat(encode_search)) ..\n                           \"])\"\n  local encode_repl = encode_translate\n\n  function codec:Encode(str)\n    if type(str) ~= \"string\" then\n      error(\n        (\"Usage: codec:Encode(str):\" .. \" 'str' - string expected got '%s'.\"):format(\n          type(str)), 2)\n    end\n    return string_gsub(str, encode_pattern, encode_repl)\n  end\n\n  local decode_tblsize = #decode_patterns\n  local decode_fail_pattern = \"([\" .. escape_for_gsub(reserved_chars) .. \"])\"\n\n  function codec:Decode(str)\n    if type(str) ~= \"string\" then\n      error(\n        (\"Usage: codec:Decode(str):\" .. \" 'str' - string expected got '%s'.\"):format(\n          type(str)), 2)\n    end\n    if string_find(str, decode_fail_pattern) then return nil end\n    for i = 1, decode_tblsize do\n      str = string_gsub(str, decode_patterns[i], decode_repls[i])\n    end\n    return str\n  end\n\n  return codec\nend\n\nlocal _addon_channel_codec\n\nlocal function GenerateWoWAddonChannelCodec()\n  return LibDeflate:CreateCodec(\"\000\", \"\001\", \"\")\nend\n\n--- Encode the string to make it ready to be transmitted in World of\n-- Warcraft addon channel. <br>\n-- The encoded string is guaranteed to contain no NULL (\"\000\") character.\n-- @param str [string] The string to be encoded.\n-- @return The encoded string.\n-- @see LibDeflate:DecodeForWoWAddonChannel\nfunction LibDeflate:EncodeForWoWAddonChannel(str)\n  if type(str) ~= \"string\" then\n    error((\"Usage: LibDeflate:EncodeForWoWAddonChannel(str):\" ..\n            \" 'str' - string expected got '%s'.\"):format(type(str)), 2)\n  end\n  if not _addon_channel_codec then\n    _addon_channel_codec = GenerateWoWAddonChannelCodec()\n  end\n  return _addon_channel_codec:Encode(str)\nend\n\n--- Decode the string produced by LibDeflate:EncodeForWoWAddonChannel\n-- @param str [string] The string to be decoded.\n-- @return [string/nil] The decoded string if succeeds. nil if fails.\n-- @see LibDeflate:EncodeForWoWAddonChannel\nfunction LibDeflate:DecodeForWoWAddonChannel(str)\n  if type(str) ~= \"string\" then\n    error((\"Usage: LibDeflate:DecodeForWoWAddonChannel(str):\" ..\n            \" 'str' - string expected got '%s'.\"):format(type(str)), 2)\n  end\n  if not _addon_channel_codec then\n    _addon_channel_codec = GenerateWoWAddonChannelCodec()\n  end\n  return _addon_channel_codec:Decode(str)\nend\n\n-- For World of Warcraft Chat Channel Encoding\n-- Credits to LibCompress.\n-- The code has been rewritten by the author of LibDeflate. <br>\n-- Following byte values are not allowed:\n-- \000, s, S, \010, \013, \124, %\n-- Because SendChatMessage will error\n-- if an UTF8 multibyte character is incomplete,\n-- all character values above 127 have to be encoded to avoid this.\n-- This costs quite a bit of bandwidth (about 13-14%)\n-- Also, because drunken status is unknown for the received\n-- , strings used with SendChatMessage should be terminated with\n-- an identifying byte value, after which the server MAY add \"...hic!\"\n-- or as much as it can fit(!).\n-- Pass the identifying byte as a reserved character to this function\n-- to ensure the encoding doesn't contain that value.\n-- or use this: local message, match = arg1:gsub(\"^(.*)\029.-$\", \"%1\")\n-- arg1 is message from channel, \029 is the string terminator\n-- , but may be used in the encoded datastream as well. :-)\n-- This encoding will expand data anywhere from:\n-- 0% (average with pure ascii text)\n-- 53.5% (average with random data valued zero to 255)\n-- 100% (only encoding data that encodes to two bytes)\nlocal function GenerateWoWChatChannelCodec()\n  local r = {}\n  for i = 128, 255 do r[#r + 1] = _byte_to_char[i] end\n\n  local reserved_chars = \"sS\000\010\013\124%\" .. table_concat(r)\n  return LibDeflate:CreateCodec(reserved_chars, \"\029\031\", \"\015\020\")\nend\n\nlocal _chat_channel_codec\n\n--- Encode the string to make it ready to be transmitted in World of\n-- Warcraft chat channel. <br>\n-- See also https://wow.gamepedia.com/ValidChatMessageCharacters\n-- @param str [string] The string to be encoded.\n-- @return [string] The encoded string.\n-- @see LibDeflate:DecodeForWoWChatChannel\nfunction LibDeflate:EncodeForWoWChatChannel(str)\n  if type(str) ~= \"string\" then\n    error((\"Usage: LibDeflate:EncodeForWoWChatChannel(str):\" ..\n            \" 'str' - string expected got '%s'.\"):format(type(str)), 2)\n  end\n  if not _chat_channel_codec then\n    _chat_channel_codec = GenerateWoWChatChannelCodec()\n  end\n  return _chat_channel_codec:Encode(str)\nend\n\n--- Decode the string produced by LibDeflate:EncodeForWoWChatChannel.\n-- @param str [string] The string to be decoded.\n-- @return [string/nil] The decoded string if succeeds. nil if fails.\n-- @see LibDeflate:EncodeForWoWChatChannel\nfunction LibDeflate:DecodeForWoWChatChannel(str)\n  if type(str) ~= \"string\" then\n    error((\"Usage: LibDeflate:DecodeForWoWChatChannel(str):\" ..\n            \" 'str' - string expected got '%s'.\"):format(type(str)), 2)\n  end\n  if not _chat_channel_codec then\n    _chat_channel_codec = GenerateWoWChatChannelCodec()\n  end\n  return _chat_channel_codec:Decode(str)\nend\n\n-- Credits to WeakAuras2 and Galmok for the 6 bit encoding algorithm.\n-- The code has been rewritten by the author of LibDeflate.\n-- The result of encoding will be 25% larger than the\n-- origin string, but every single byte of the encoding result will be\n-- printable characters as the following.\nlocal _byte_to_6bit_char = {\n  [0] = \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"(\",\n  \")\"\n}\n\nlocal _6bit_to_byte = {\n  [97] = 0,\n  [98] = 1,\n  [99] = 2,\n  [100] = 3,\n  [101] = 4,\n  [102] = 5,\n  [103] = 6,\n  [104] = 7,\n  [105] = 8,\n  [106] = 9,\n  [107] = 10,\n  [108] = 11,\n  [109] = 12,\n  [110] = 13,\n  [111] = 14,\n  [112] = 15,\n  [113] = 16,\n  [114] = 17,\n  [115] = 18,\n  [116] = 19,\n  [117] = 20,\n  [118] = 21,\n  [119] = 22,\n  [120] = 23,\n  [121] = 24,\n  [122] = 25,\n  [65] = 26,\n  [66] = 27,\n  [67] = 28,\n  [68] = 29,\n  [69] = 30,\n  [70] = 31,\n  [71] = 32,\n  [72] = 33,\n  [73] = 34,\n  [74] = 35,\n  [75] = 36,\n  [76] = 37,\n  [77] = 38,\n  [78] = 39,\n  [79] = 40,\n  [80] = 41,\n  [81] = 42,\n  [82] = 43,\n  [83] = 44,\n  [84] = 45,\n  [85] = 46,\n  [86] = 47,\n  [87] = 48,\n  [88] = 49,\n  [89] = 50,\n  [90] = 51,\n  [48] = 52,\n  [49] = 53,\n  [50] = 54,\n  [51] = 55,\n  [52] = 56,\n  [53] = 57,\n  [54] = 58,\n  [55] = 59,\n  [56] = 60,\n  [57] = 61,\n  [40] = 62,\n  [41] = 63\n}\n\n--- Encode the string to make it printable. <br>\n--\n-- Credit to WeakAuras2, this function is equivalant to the implementation\n-- it is using right now. <br>\n-- The code has been rewritten by the author of LibDeflate. <br>\n-- The encoded string will be 25% larger than the origin string. However, every\n-- single byte of the encoded string will be one of 64 printable ASCII\n-- characters, which are can be easier copied, pasted and displayed.\n-- (26 lowercase letters, 26 uppercase letters, 10 numbers digits,\n-- left parenthese, or right parenthese)\n-- @param str [string] The string to be encoded.\n-- @return [string] The encoded string.\nfunction LibDeflate:EncodeForPrint(str)\n  if type(str) ~= \"string\" then\n    error((\"Usage: LibDeflate:EncodeForPrint(str):\" ..\n            \" 'str' - string expected got '%s'.\"):format(type(str)), 2)\n  end\n  local strlen = #str\n  local strlenMinus2 = strlen - 2\n  local i = 1\n  local buffer = {}\n  local buffer_size = 0\n  while i <= strlenMinus2 do\n    local x1, x2, x3 = string_byte(str, i, i + 2)\n    i = i + 3\n    local cache = x1 + x2 * 256 + x3 * 65536\n    local b1 = cache % 64\n    cache = (cache - b1) / 64\n    local b2 = cache % 64\n    cache = (cache - b2) / 64\n    local b3 = cache % 64\n    local b4 = (cache - b3) / 64\n    buffer_size = buffer_size + 1\n    buffer[buffer_size] = _byte_to_6bit_char[b1] .. _byte_to_6bit_char[b2] ..\n                            _byte_to_6bit_char[b3] .. _byte_to_6bit_char[b4]\n  end\n\n  local cache = 0\n  local cache_bitlen = 0\n  while i <= strlen do\n    local x = string_byte(str, i, i)\n    cache = cache + x * _pow2[cache_bitlen]\n    cache_bitlen = cache_bitlen + 8\n    i = i + 1\n  end\n  while cache_bitlen > 0 do\n    local bit6 = cache % 64\n    buffer_size = buffer_size + 1\n    buffer[buffer_size] = _byte_to_6bit_char[bit6]\n    cache = (cache - bit6) / 64\n    cache_bitlen = cache_bitlen - 6\n  end\n\n  return table_concat(buffer)\nend\n\n--- Decode the printable string produced by LibDeflate:EncodeForPrint.\n-- \"str\" will have its prefixed and trailing control characters or space\n-- removed before it is decoded, so it is easier to use if \"str\" comes form\n-- user copy and paste with some prefixed or trailing spaces.\n-- Then decode fails if the string contains any characters cant be produced by\n-- LibDeflate:EncodeForPrint. That means, decode fails if the string contains a\n-- characters NOT one of 26 lowercase letters, 26 uppercase letters,\n-- 10 numbers digits, left parenthese, or right parenthese.\n-- @param str [string] The string to be decoded\n-- @return [string/nil] The decoded string if succeeds. nil if fails.\nfunction LibDeflate:DecodeForPrint(str)\n  if type(str) ~= \"string\" then\n    error((\"Usage: LibDeflate:DecodeForPrint(str):\" ..\n            \" 'str' - string expected got '%s'.\"):format(type(str)), 2)\n  end\n  str = str:gsub(\"^[%c ]+\", \"\")\n  str = str:gsub(\"[%c ]+$\", \"\")\n\n  local strlen = #str\n  if strlen == 1 then return nil end\n  local strlenMinus3 = strlen - 3\n  local i = 1\n  local buffer = {}\n  local buffer_size = 0\n  while i <= strlenMinus3 do\n    local x1, x2, x3, x4 = string_byte(str, i, i + 3)\n    x1 = _6bit_to_byte[x1]\n    x2 = _6bit_to_byte[x2]\n    x3 = _6bit_to_byte[x3]\n    x4 = _6bit_to_byte[x4]\n    if not (x1 and x2 and x3 and x4) then return nil end\n    i = i + 4\n    local cache = x1 + x2 * 64 + x3 * 4096 + x4 * 262144\n    local b1 = cache % 256\n    cache = (cache - b1) / 256\n    local b2 = cache % 256\n    local b3 = (cache - b2) / 256\n    buffer_size = buffer_size + 1\n    buffer[buffer_size] = _byte_to_char[b1] .. _byte_to_char[b2] ..\n                            _byte_to_char[b3]\n  end\n\n  local cache = 0\n  local cache_bitlen = 0\n  while i <= strlen do\n    local x = string_byte(str, i, i)\n    x = _6bit_to_byte[x]\n    if not x then return nil end\n    cache = cache + x * _pow2[cache_bitlen]\n    cache_bitlen = cache_bitlen + 6\n    i = i + 1\n  end\n\n  while cache_bitlen >= 8 do\n    local byte = cache % 256\n    buffer_size = buffer_size + 1\n    buffer[buffer_size] = _byte_to_char[byte]\n    cache = (cache - byte) / 256\n    cache_bitlen = cache_bitlen - 8\n  end\n\n  return table_concat(buffer)\nend\n\nlocal function InternalClearCache()\n  _chat_channel_codec = nil\n  _addon_channel_codec = nil\nend\n\n-- For test. Don't use the functions in this table for real application.\n-- Stuffs in this table is subject to change.\nLibDeflate.internals = {\n  LoadStringToTable = LoadStringToTable,\n  IsValidDictionary = IsValidDictionary,\n  IsEqualAdler32 = IsEqualAdler32,\n  _byte_to_6bit_char = _byte_to_6bit_char,\n  _6bit_to_byte = _6bit_to_byte,\n  InternalClearCache = InternalClearCache\n}\n\n--[[-- Commandline options\n@class table\n@name CommandlineOptions\n@usage lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]\n\-0    store only. no compression.\n\-1    fastest compression.\n\-9    slowest and best compression.\n\-d    do decompression instead of compression.\n\--dict <filename> specify the file that contains\nthe entire preset dictionary.\n\-h    give this help.\n\--strategy <fixed/huffman_only/dynamic> specify a special compression strategy.\n\-v    print the version and copyright info.\n\--zlib  use zlib format instead of raw deflate.\n]]\n\n-- currently no plan to support stdin and stdout.\n-- Because Lua in Windows does not set stdout with binary mode.\nif io and os and debug and _G.arg then\n  local io = io\n  local os = os\n  local debug = debug\n  local arg = _G.arg\n  local debug_info = debug.getinfo(1)\n  if debug_info.source == arg[0] or debug_info.short_src == arg[0] then\n    -- We are indeed runnning THIS file from the commandline.\n    local input\n    local output\n    local i = 1\n    local status\n    local is_zlib = false\n    local is_decompress = false\n    local level\n    local strategy\n    local dictionary\n    while (arg[i]) do\n      local a = arg[i]\n      if a == \"-h\" then\n        print(LibDeflate._COPYRIGHT ..\n                \"\nUsage: lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]\n\" ..\n                \"  -0    store only. no compression.\n\" ..\n                \"  -1    fastest compression.\n\" ..\n                \"  -9    slowest and best compression.\n\" ..\n                \"  -d    do decompression instead of compression.\n\" ..\n                \"  --dict <filename> specify the file that contains\" ..\n                \" the entire preset dictionary.\n\" ..\n                \"  -h    give this help.\n\" ..\n                \"  --strategy <fixed/huffman_only/dynamic>\" ..\n                \" specify a special compression strategy.\n\" ..\n                \"  -v    print the version and copyright info.\n\" ..\n                \"  --zlib  use zlib format instead of raw deflate.\n\")\n        os.exit(0)\n      elseif a == \"-v\" then\n        print(LibDeflate._COPYRIGHT)\n        os.exit(0)\n      elseif a:find(\"^%-[0-9]$\") then\n        level = tonumber(a:sub(2, 2))\n      elseif a == \"-d\" then\n        is_decompress = true\n      elseif a == \"--dict\" then\n        i = i + 1\n        local dict_filename = arg[i]\n        if not dict_filename then\n          io.stderr:write(\"You must speicify the dict filename\")\n          os.exit(1)\n        end\n        local dict_file, dict_status = io.open(dict_filename, \"rb\")\n        if not dict_file then\n          io.stderr:write(\n            (\"LibDeflate: Cannot read the dictionary file '%s': %s\"):format(\n              dict_filename, dict_status))\n          os.exit(1)\n        end\n        local dict_str = dict_file:read(\"*all\")\n        dict_file:close()\n        -- In your lua program, you should pass in adler32 as a CONSTANT\n        -- , so it actually prevent you from modifying dictionary\n        -- unintentionally during the program development. I do this\n        -- here just because no convenient way to verify in commandline.\n        dictionary = LibDeflate:CreateDictionary(dict_str, #dict_str,\n                                                 LibDeflate:Adler32(dict_str))\n      elseif a == \"--strategy\" then\n        -- Not sure if I should check error here\n        -- If I do, redudant code.\n        i = i + 1\n        strategy = arg[i]\n      elseif a == \"--zlib\" then\n        is_zlib = true\n      elseif a:find(\"^%-\") then\n        io.stderr:write((\"LibDeflate: Invalid argument: %s\"):format(a))\n        os.exit(1)\n      else\n        if not input then\n          input, status = io.open(a, \"rb\")\n          if not input then\n            io.stderr:write(\n              (\"LibDeflate: Cannot read the file '%s': %s\"):format(a, tostring(\n                                                                     status)))\n            os.exit(1)\n          end\n        elseif not output then\n          output, status = io.open(a, \"wb\")\n          if not output then\n            io.stderr:write(\n              (\"LibDeflate: Cannot write the file '%s': %s\"):format(a, tostring(\n                                                                      status)))\n            os.exit(1)\n          end\n        end\n      end\n      i = i + 1\n    end -- while (arg[i])\n\n    if not input or not output then\n      io.stderr:write(\"LibDeflate:\" ..\n                        \" You must specify both input and output files.\")\n      os.exit(1)\n    end\n\n    local input_data = input:read(\"*all\")\n    local configs = {level = level, strategy = strategy}\n    local output_data\n    if not is_decompress then\n      if not is_zlib then\n        if not dictionary then\n          output_data = LibDeflate:CompressDeflate(input_data, configs)\n        else\n          output_data = LibDeflate:CompressDeflateWithDict(input_data,\n                                                           dictionary, configs)\n        end\n      else\n        if not dictionary then\n          output_data = LibDeflate:CompressZlib(input_data, configs)\n        else\n          output_data = LibDeflate:CompressZlibWithDict(input_data, dictionary,\n                                                        configs)\n        end\n      end\n    else\n      if not is_zlib then\n        if not dictionary then\n          output_data = LibDeflate:DecompressDeflate(input_data)\n        else\n          output_data = LibDeflate:DecompressDeflateWithDict(input_data,\n                                                             dictionary)\n        end\n      else\n        if not dictionary then\n          output_data = LibDeflate:DecompressZlib(input_data)\n        else\n          output_data =\n            LibDeflate:DecompressZlibWithDict(input_data, dictionary)\n        end\n      end\n    end\n\n    if not output_data then\n      io.stderr:write(\"LibDeflate: Decompress fails.\")\n      os.exit(1)\n    end\n\n    output:write(output_data)\n    if input and input ~= io.stdin then input:close() end\n    if output and output ~= io.stdout then output:close() end\n\n    io.stderr:write((\"Successfully writes %d bytes\"):format(output_data:len()))\n    os.exit(0)\n  end\nend\n\nreturn LibDeflate"
local descendantModuleScript9 = Instance.new("ModuleScript", descendantModuleScript8)
descendantModuleScript9.Name = "Mesh"
descendantModuleScript9.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\n\n\nlocal Point = e.Point\n\nlocal Mesh = {}\nMesh.MT = { __index = Mesh }\nfunction Mesh.new()\n	return setmetatable({\n		points = {};\n		reflexes = {};\n		surfaces = {};\n		barriers = {};\n		connections = {};\n		c_conns = {};\n\n		octree = e.Octree.Octree(0, 0, 0, 10);\n\n		Name = 'Mesh';\n		Visible = false;\n	}, Mesh.MT)\nend\n\nfunction Mesh:reset()\n\n	self.octree = e.Octree.Octree(0, 0, 0, 10);\n\nend\n\nfunction Mesh:add_point(point)\n	local id = #self.points + 1\n	self.points[id] = point\n	point.id = id\n	if point.ptype >= Point.REFLEX then\n		self.reflexes[point] = true\n	end\nend\n\nfunction Mesh:add_surface(surface)\n	local id = #self.surfaces + 1\n	self.surfaces[id] = surface\n	surface.id = id\nend\n\nfunction Mesh:add_barrier(surface)\n	local id = #self.barriers + 1\n	self.barriers[id] = surface\n	surface.id = id\n	surface.is_barrier = true\nend\n\nfunction Mesh:add_action(action)\n	local id = #self.c_conns + 1\n	self.c_conns[id] = action\n	action.id = id\nend\n\nfunction Mesh:load_surfaces()\n	local tree = self.octree\n	for i, s in ipairs(self.surfaces) do\n\n		tree:add(s:get_AABB(), s)\n\n	end\nend\n\nfunction Mesh:rmv_point(point)\n	local t = self.points\n	local rep = t[#t]\n	t[point.id] = rep\n	if rep then\n		t[#t] = nil\n		rep.id = point.id\n	end\n	point.id = nil\nend\n\n\nfunction Mesh:remove(surface)\n	local t = self.surfaces\n	local rep = t[#t]\n	t[surface.id] = rep\n	t[#t] = nil\n\n	local aabb = surface:get_AABB()\n	self.octree:remove(aabb, surface)\n	\n	if rep then\n		rep.id = surface.id\n	end\n	\n	surface.id = nil\n\n	for i, p in ipairs(surface) do\n		p.surfaces[surface] = nil\n		if not next(p.surfaces) then\n			self:rmv_point(p)\n		end\n	end\nend\n\n\n\nfunction Mesh:get_ground(point, radius)\n	local g_min = Vector3.new(-radius, -math.huge, -radius)\n	local g_max = Vector3.new(radius, 0, radius)\n\n	local surfaces = {}\n	local j_AABB = e.AABB(\n		point + g_min,\n		point + g_max\n	)\n\n\n\n	self.octree:intersection(\n		j_AABB,\n		surfaces\n	)\n\n\n	\n	if #surfaces == 0 then\n\n		return\n	end\n\n\n\n	local best\n	local best_y = -math.huge\n	for i, ground in ipairs(surfaces) do\n\n		if ground:is_in_bounds(point) then\n			local y = surfaces[i]:get_height(point)\n\n			if y > best_y then\n\n				best_y = y\n				best = ground\n			end\n		end\n\n	end\n\n\n\n	if best == nil then\n\n		return\n	end\n\n\n\n	return {\n		mesh = self;\n		surface = best;\n		point = point;\n	}\nend\n\n\nfunction Mesh:cache_lines()\n    for i, s in ipairs(self.surfaces) do\n        s:cache_lines()\n    end\n    for i, p in ipairs(self.points) do\n        for s in next, p.surfaces do\n            if not s.is_barrier and not p.lines_by_s[s] then\n                error('bad cache lines. ' .. p.id .. ' has ' .. s.id .. ' in surfaces, but not lines_by_s.')\n            end\n        end\n    end\nend\n\n\n\nreturn Mesh"
local descendantModuleScript10 = Instance.new("ModuleScript", descendantModuleScript9)
descendantModuleScript10.Name = "Octree"
descendantModuleScript10.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\n\n--Tyler R. Hoyer\n--August 22, 2014\n--Volumetric AABB Octree with Intersection Test and Commenting\n--TylerRichardHoyer@gmail.com\n\nlocal Octree = {}\nlocal Octree_metatable = {__index = Octree}\n\n--The smallest size of a cell\nlocal MINIMUM_SIZE = 1\n\n--Create a new Octree\n--Returns a table\nfunction Octree.Octree(x, y, z, size) \n	return setmetatable({\n		x, y, z; --The center (1, 2, 3)\n		\n		size; --The size of the cell as power of 2 (4)\n		\n		{}; --The list of values inside of the cell (5)\n		\n		--The eight sub-cells (xyz sorted, lowest first)\n		false, false, false, false; --(6, 7, 8, 9)\n		false, false, false, false; --(10, 11, 12, 13)\n	}, Octree_metatable)\nend\n\n--Get the index of a child\n--Returns an integer or false\nfunction Octree:child(aabb)\n\n	--The size of the cell's children\n	local children_size = 2^(self[4] - 1)\n	\n	--Check that the children are big enough\n	if children_size < MINIMUM_SIZE then\n		return false\n	end\n\n	--The cell's center point\n	local x = self[1]\n	local y = self[2]\n	local z = self[3]\n\n	--The min point's octant relative to the center point of the cell\n	local lesser_x = aabb.min.X <= x\n	local lesser_y = aabb.min.Y <= y\n	local lesser_z = aabb.min.Z <= z\n	\n	--Check if the max and min points are in the same child\n	if lesser_x == (aabb.max.X <= x) \n		and lesser_y == (aabb.max.Y <= y) \n		and lesser_z == (aabb.max.Z <= z) then\n		\n		--Return the child's index\n		return 6 \n			+ (lesser_x and 0 or 4) \n			+ (lesser_y and 0 or 2) \n			+ (lesser_z and 0 or 1)\n	end\n\n	--Return false, in multiple children\n	return false\nend\n\n--Remove a value\n--Returns a boolean\nfunction Octree:remove(aabb, value)\n\n	--If the value is in a child, get it's index\n	local child_index = self:child(aabb)\n	\n	--Check if the value belongs in a child\n	if child_index then\n		local child = self[child_index]\n\n		if not child then\n			--Value's container does not exist, return cell not changed\n			return false, false\n		end\n\n		--Remove the value from the child cell\n		local success, child_updated = child:remove(aabb, value)\n\n		--Check if the child can be deleted\n		--Must have been updated, have no values, and have no children\n		if child_updated and not next(child[5]) and not (\n			child[6] or child[7] or child[8] or child[9] \n			or child[10] or child[11] or child[12] or child[13]) then\n			self[child_index] = false\n\n			--Value removed, return cell changed\n			return true, true\n		end\n\n		--Value removed, return cell not changed\n		return true, false\n	end\n\n	--Search the cell's values\n	local values = self[5]\n	for k, v in next, values do\n\n		--Check if the value is the value that needs to be deleted\n		if v == value then\n			values[k] = nil\n\n			--Value removed, return cell changed\n			return true, true\n		end\n	end\n	\n	--Value not found, return cell not changed\n	return false, false\nend\n\n--Add a value\n--Returns nil\nfunction Octree:add(aabb, value)\n\n	--If the value is in a child, get it's index\n	local child_index = self:child(aabb)\n	\n	--Check if the value belongs in a child\n	if child_index then\n		local child = self[child_index]\n\n		--Create the child if it does not exist\n		if not child then\n			local offset = 2 ^ (self[4] - 2)\n			local child_x = self[1] + (aabb.min.X <= self[1] and -offset or offset)\n			local child_y = self[2] + (aabb.min.Y <= self[2] and -offset or offset)\n			local child_z = self[3] + (aabb.min.Z <= self[3] and -offset or offset)\n			child = Octree.Octree(child_x, child_y, child_z, self[4] - 1)\n			self[child_index] = child\n		end\n		\n		--Add the value to the child (tail call for speed, returns nil)\n		return child:add(aabb, value)\n	end\n	\n	--Add the value to this cell\n	local values = self[5]\n	values[aabb] = value\nend\n\n--Get values intersecting an AABB\n--Returns nil, result argument contains resultant values\n--Beware: this recursive function calls itself in a sub-recursive function\nfunction Octree:intersection(aabb, result)\n\n	--Append the values in the cell to the result\n	local values = self[5]\n	for key, value in next, values do\n		if aabb:intersection(key) then\n			result[#result + 1] = value\n		end\n	end\n\n	--The center point of the cell\n	local x = self[1]\n	local y = self[2]\n	local z = self[3]\n\n	--The min point's octant relative to the center of the cell\n	local lesser = {\n		aabb.min.Z <= z,\n		aabb.min.Y <= y,\n		aabb.min.X <= x}\n\n	--The true if the min and max points are in different octants\n	local split = {\n		lesser[1] ~= (aabb.max.Z <= z),\n		lesser[2] ~= (aabb.max.Y <= y),\n		lesser[3] ~= (aabb.max.X <= x)}\n\n	--This is very complex on multiple levels. The goal is to find out what octants contain\n	--the AABB defined by the min and max points. It does this by checking each axis. For each\n	--axis, the min and max points can be less than, greater than, or split around the center\n	--offset. Once one axis is determined, then it checks the next axis. Once all three are\n	--checked, it checks the current point defined by them. If an axis is split, it checks the\n	--first side for the rest of the axises, then checks the other side. It is simplest, fastest,\n	--and easiest to write in a recursive function.\n	local function check(current, i)\n\n		--If the checks are done\n		if i == 0 then\n			local child = self[current]\n			--Check if the child exists\n\n			if child then\n				--Add values contained in the child\n				return child:intersection(aabb, result)\n			end\n			\n			return result\n\n		--Check if split\n		elseif split[i] then\n			--Add lesser side\n			check(current, i - 1)\n			--Add greater side\n			return check(current + 2^(i - 1), i - 1)\n\n		--Check if on lesser side\n		elseif lesser[i] then\n			--Add lesser side\n			return check(current, i - 1)\n\n		else\n			--Add greater side\n			return check(current + 2^(i - 1), i - 1)\n		end\n	end\n\n	--Start the checks. Returns nil\n	return check(6, 3)\nend\n\nreturn Octree\n\n"
local descendantModuleScript11 = Instance.new("ModuleScript", descendantModuleScript10)
descendantModuleScript11.Name = "Point"
descendantModuleScript11.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\n\n\n\n\nlocal Point = {\n	\n		[\"UNKNOWN\"] = 0;\n	\n		[\"INTERIOR\"] = 1;\n	\n		[\"MIDEXTERIOR\"] = 2;\n	\n		[\"EXTERIOR\"] = 3;\n	\n		[\"REFLEX\"] = 4;\n	\n		[\"INTER\"] = 5;\n	\n		[\"ACTION\"] = 6;\n	\n		[\"GOAL\"] = 7;\n	\n		[\"BLOCKED\"] = 8;\n	\n}\nlocal ptype_name = {\n	\n		[0] = \"UNKNOWN\";\n	\n		[1] = \"INTERIOR\";\n	\n		[2] = \"MIDEXTERIOR\";\n	\n		[3] = \"EXTERIOR\";\n	\n		[4] = \"REFLEX\";\n	\n		[5] = \"INTER\";\n	\n		[6] = \"ACTION\";\n	\n		[7] = \"GOAL\";\n	\n		[8] = \"BLOCKED\";\n	\n}\nPoint.is_reflex = {\n	[Point.REFLEX] = true;\n	[Point.INTER] = true;\n	[Point.ACTION] = true;\n	[Point.GOAL] = true;\n}\n\nPoint.MT = {__index = Point}\n\nlocal util = e.util\nfunction Point.new(v3, ptype)\n	return setmetatable({\n		v3 = v3;\n		id = nil;\n		surfaces = {};\n		lines_by_p = {};\n		lines_by_s = {};\n		sight = {};\n		ptype = ptype;\n	}, Point.MT)\nend\nfunction Point:add(surface, i)\n	self.surfaces[surface] = i\nend\nfunction Point:rmv(surface)\n	self.surfaces[surface] = nil\nend\n\nfunction Point:remove()\n	if self.part then\n		self:destroy()\n	end\n\n	if self.ptype == Point.ACTION then\n		for s, c_conn in next, self.surfaces do\n			c_conn:destroy()\n			s.c_conns[self] = nil\n		end\n	else\n		for s, i in next, self.surfaces do\n			s:rmv(i)\n			s:update()\n		end\n	end\nend\n\nlocal function insert(t, k, v)\n	local cur = t[k]\n	if cur then\n		cur[#cur + 1] = v\n	else\n		t[k] = {v}\n	end\nend\nfunction Point:cache_line(other, surface)\n	insert(self.lines_by_p, other, surface)\n	insert(self.lines_by_s, surface, other)\nend\n\nfunction Point.MT:__tostring()\n	return ('<Point id=%d ptype=%s v3=%s>'):format(\n		self.id,\n		ptype_name[self.ptype],\n		tostring(self.v3)\n	)\nend\n\nreturn Point"
local descendantModuleScript12 = Instance.new("ModuleScript", descendantModuleScript11)
descendantModuleScript12.Name = "Queue"
descendantModuleScript12.Source = "-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nlocal Queue = {}\nlocal MT = {\n	__index = Queue\n}\n\nsetmetatable(Queue, {\n	__call = function(self, t)\n		return setmetatable(t or {}, MT)\n	end,\n})\n\nfunction Queue:pop()\n	local cur = 1\n	local child = 2 * cur\n	local min = self[1]\n	local element = self[#self]\n	\n	self[#self] = nil\n	if #self == 0 then\n		return min\n	end\n\n	while child < #self do\n		if self[child + 1].value < self[child].value then\n			child = child + 1\n		end\n		if element.value <= self[child].value then\n			self[cur] = element\n			element.index = cur\n\n			return min\n		else\n			self[cur] = self[child]\n			self[cur].index = cur\n			cur = child\n			child = 2 * cur\n		end\n	end\n	if child == #self and element.value > self[child].value then\n		self[cur] = self[child]\n		self[cur].index = cur\n		cur = child\n	end\n	self[cur] = element\n	element.index = cur\n	\n	return min\nend\n\nfunction Queue:insert(element)\n	local cur = #self + 1\n	local p = (cur - cur % 2) / 2\n	while p > 0 do\n		if element.value <= self[p].value then\n			self[cur] = self[p]\n			self[cur].index = cur\n			cur = p\n			p = (cur - cur % 2) / 2\n		else\n			self[cur] = element\n			element.index = cur\n			return\n		end\n	end\n	self[cur] = element\n	element.index = cur\nend\n\nfunction Queue:decrease(element)\n	local cur = element.index\n	local p = (cur - cur % 2) / 2\n	while p > 0 do\n		if element.value <= self[p].value then\n			self[cur] = self[p]\n			self[cur].index = cur\n			cur = p\n			p = (cur - cur % 2) / 2\n		else\n			self[cur] = element\n			element.index = cur\n			return\n		end\n	end\nend\n\nreturn Queue"
local descendantModuleScript13 = Instance.new("ModuleScript", descendantModuleScript12)
descendantModuleScript13.Name = "Surface"
descendantModuleScript13.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\nlocal AABB = e.AABB\n\n\nlocal util = e.util\n\nlocal max_rejection_per_stud = 1e-7\n\nlocal min_normal = 1 - math.sin(math.rad(89))\n\nlocal h_delta = 1e-3\n\nlocal mrps_cos = math.cos(max_rejection_per_stud)\n\nlocal down = Vector3.new(0, -1, 0)\nlocal up = Vector3.new(0, 1, 0)\n\nlocal Point = e.Point\n\nlocal Surface = {\n	thickness = 0.01\n}\nSurface.MT = { __index = Surface }\nfunction Surface.new(pts)\n	local is_valid, normal = Surface.calc_normal(pts)\n	if not is_valid then\n		return false\n	end\n	pts.normal = normal\n	pts.connections = {}\n	pts.c_conns = {}\n	pts.adjacent = {}\n	return setmetatable(pts, Surface.MT)\nend\n\nfunction Surface:notify_points()\n	for i, p in ipairs(self) do\n		p:add(self, i)\n	end\nend\n\nfunction Surface:calc_normal()\n	local n = #self\n	local a = self[n]\n	local b = self[1]\n	local delta = b.v3 - a.v3\n\n	local delta_mag = delta.Magnitude\n\n	if delta_mag < util.prec then\n		return false\n	end\n	local ab_u = delta / delta_mag\n	local best_v = 0\n	local best_cos = 1\n	for i = 1, #self - 1 do\n		local c = self[i]\n		delta = c.v3 - a.v3\n\n		delta_mag = delta.Magnitude\n\n		if delta_mag < util.prec then\n			return false\n		end\n		local ac_u = delta / delta_mag\n		local cos_abs = math.abs(ab_u:Dot(ac_u))\n		if cos_abs < best_cos then\n			best_cos = cos_abs\n			best_v = ac_u\n		end\n	end\n\n	if best_cos > mrps_cos or best_cos < -mrps_cos then\n		return false\n	end\n\n	return true, best_v:Cross(ab_u)\nend\n\nfunction Surface:rmv(id)\n	-- Surface is no longer valid\n	if #self <= 3 then\n		return true\n	end\n\n	local n = #self\n	local i = id\n	local j = i + 1\n	while j <= n do\n		local p = self[j]\n		self[i] = p\n		p.surfaces[self] = i\n		i = j\n		j = j + 1\n	end\n	self[n] = nil\nend\n\nfunction Surface:is_convex()\n	local a, b = self[#self - 1].v3, self[#self].v3\n	for i, c in ipairs(self) do\n		c = c.v3\n		local ab = b - a\n		local ac = c - a\n		local dot = ac:Cross(ab):Dot(self.normal)\n		if dot < -1e-3 or dot < 1e-7 and ab:Dot(ac) < 0 then\n			return false\n		end\n		a = b\n		b = c\n	end\n	return true\nend\n\nfunction Surface:is_coplanar()\n	local dot = self[1].v3:Dot(self.normal)\n	for i, a in ipairs(self) do\n		if math.abs(a.v3:Dot(self.normal) - dot) > 1e-7 then\n			return false\n		end\n	end\n	return true\nend\n\nfunction Surface:next_i(i)\n	if self.normal.Y < 0 then\n		return i > 1 and i - 1 or #self\n	else\n		return i < (#self) and i + 1 or 1\n	end\nend\n\nfunction Surface:prev_i(i)\n	if self.normal.Y < 0 then\n		return i < (#self) and i + 1 or 1\n	else\n		return i > 1 and i - 1 or #self\n	end\nend\n\n-- true if inside surface\n-- nil if on boundary\n-- false if outside\nfunction Surface:is_in_bounds(v3)\n	local a = self[#self].v3\n	local normal = self.normal\n	for i, b in ipairs(self) do\n		b = b.v3\n		--local normal_p = create_line(a, 5 * normal, workspace)\n		--normal_p.Color = Color3.new(1, 0, 0)\n		local ab = b - a\n		local ap = v3 - a\n		--local ab_p = create_line(a, ab, workspace)\n		--ab_p.Color = Color3.new(0, 1, 0)\n		--local ap_p = create_line(a, ap, workspace)\n		--ap_p.Color = Color3.new(0, 0, 1)\n		local cross = ab:Cross(ap)\n		--local cross_p = create_line(a, cross, workspace)\n		--cross_p.Color = Color3.new(1, 1, 0)\n		--print(dot)\n		--wait(5)\n		--ab_p:Destroy()\n		--ap_p:Destroy()\n		--cross_p:Destroy()\n		--normal_p:Destroy()\n		if cross.Y > 0 then\n			return false\n		elseif cross.Y == 0 then\n\n			local ap_m = ap.Magnitude\n			local t = ab.Unit:Dot(ap) / ab.Magnitude\n\n			if ap_m == 0 or t >= 0 and t <= 1 then\n				return nil\n			else\n				return false\n			end\n		end\n		a = b\n	end\n	return true\nend\n\nfunction Surface:get_height(v3)\n	local cos = up:Dot(self.normal)\n	if math.abs(cos) < 1e-7 then\n		return 0\n	end\n	local v = v3 - self[1].v3\n	return v:Dot(self.normal) / cos\nend\n\nfunction Surface:get_points(i)\n	return self[self:prev_i(i)].v3, self[i].v3\nend\n\nfunction Surface:get_p(i, t)\n	local a, b = self:get_points(i)\n	return a + (b - a) * t\nend\n\nfunction Surface:cache_lines()\n	local adj = self.adjacent\n	local prev = self[#self]\n	-- print('Cache Lines, #self = ' .. #self)\n	for i, p in ipairs(self) do\n		-- print(p.id .. ' is in surface ' .. self.id)\n		-- print(p.id .. ' is connected to ' .. prev.id)\n		p:cache_line(prev, self)\n		prev:cache_line(p, self)\n\n		for s, sid in next, p.surfaces do\n			if s[s:next_i(sid)] == prev then\n				adj[i] = s\n				break\n			end\n		end\n\n		prev = p\n	end\nend\n\nfunction Surface:get_min_max()\n	local p = self[1].v3\n	local minx, maxx = p.X, p.X\n	local miny, maxy = p.Y, p.Y\n	local minz, maxz = p.Z, p.Z\n	for i = 2, #self do\n		p = self[i].v3\n		if p.X < minx then\n			minx = p.X\n		elseif p.X > maxx then\n			maxx = p.X\n		end\n		if p.Y < miny then\n			miny = p.Y\n		elseif p.Y > maxy then\n			maxy = p.Y\n		end\n		if p.Z < minz then\n			minz = p.Z\n		elseif p.Z > maxz then\n			maxz = p.Z\n		end\n	end\n	return Vector3.new(minx, miny, minz),\n		Vector3.new(maxx, maxy, maxz)\nend\n\nfunction Surface:get_AABB()\n	return AABB(self:get_min_max())\nend\n\n\nfunction Surface:project_down(point)\n	local height = self:get_height(point)\n	return point - up * height, height\nend\n\n\n\n\nfunction Surface.MT:__tostring()\n	local pts_str = {''}\n	for i, p in ipairs(self) do\n		pts_str[i + 1] = tostring(p.v3)\n	end\n	return ('<Surface id=%d points={%s\n}>'):format(\n		self.id or -1,\n		table.concat(pts_str,'\n\t')\n	)\nend\n\nreturn Surface"
local descendantModuleScript14 = Instance.new("ModuleScript", descendantModuleScript13)
descendantModuleScript14.Name = "actions"
descendantModuleScript14.Source = "-- Polaris-Nav, advanced pathfinding as a library and service
\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer
\n-- tyler@hoyerz.com
\n--
\n-- This program is free software; you can redistribute it and/or
\n-- modify it under the terms of the GNU Lesser General Public
\n-- License as published by the Free Software Foundation; either
\n-- version 3 of the License, or (at your option) any later version.
\n--
\n-- This program is distributed in the hope that it will be useful,
\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of
\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\n-- Lesser General Public License for more details.
\n--
\n-- You should have received a copy of the GNU General Public License
\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.
\n
\n--[[
\nConnection:
\n	[method] consider(agent, at, at_t_min, at_t_opt) -> {
\n		{
\n			cost
\n			to_t
\n			to
\n		}
\n	}
\n	[method] perform(agent, choice) -> nil
\n	[method] create(parent) -> nil
\n	[method] destroy() -> nil
\n	[method] update() -> nil
\n	[method] save() -> string
\n	[method] load(str) -> nil
\n	[property: array] at = {}
\n	[property: array] to = {}
\n	[property: boolean] bidirectional
\n	[property: string] type
\n	[property: table] MT
\n]]
\n
\nreturn {
\n	Jump = require(script.Jump);
\n}"
local descendantModuleScript15 = Instance.new("ModuleScript", descendantModuleScript14)
descendantModuleScript15.Name = "Jump"
descendantModuleScript15.Source = "-- Polaris-Nav, advanced pathfinding as a library and service
\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer
\n-- tyler@hoyerz.com
\n--
\n-- This program is free software; you can redistribute it and/or
\n-- modify it under the terms of the GNU Lesser General Public
\n-- License as published by the Free Software Foundation; either
\n-- version 3 of the License, or (at your option) any later version.
\n--
\n-- This program is distributed in the hope that it will be useful,
\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of
\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\n-- Lesser General Public License for more details.
\n--
\n-- You should have received a copy of the GNU General Public License
\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.
\n
\nlocal e = require(script.Parent.Parent)
\n
\nlocal Jump = {
\n	type = 'Jump';
\n}
\nJump.MT = {__index = Jump}
\nlocal Action_MT = {}
\n
\nlocal empty = {}
\n
\nfunction Action_MT:__call(connection)
\n	local to = next(connection.to)
\n	local at = next(connection.at)
\n	local v = to.v3 - at.v3
\n	connection.x_distance = math.sqrt(v.X * v.X + v.Z * v.Z)
\n	connection.y_distance = v.Y
\n	return setmetatable(connection, Jump.MT)
\nend
\n
\nfunction Jump.MT:__tostring()
\n	return '<Action type=' .. Jump.type .. '>'
\nend
\n
\nfunction Jump:consider(agent, at, at_t_min, at_t_opt)
\n	if not (self.at[at] or self.bidirectional and self.to[at]) then
\n		return empty
\n	end
\n
\n	local to = next(self.to)
\n	local cost = (at.v3 - to.v3).Magnitude
\n	local dt = cost / agent.speed
\n	return {
\n		{
\n			perform = self.perform;
\n			cost = dt;
\n			to = next(self.to);
\n			to_t = at_t_min + dt
\n		}
\n	}
\nend
\n
\nfunction Jump.perform(choice, agent)
\n	local human = agent.humanoid
\n	human.Jump = true
\n	human:MoveTo(choice.to.v3)
\n	human.MoveToFinished:Wait()
\nend
\n
\nfunction Jump:create(parent)
\n	if self.line then
\n		return
\n	end
\n	local at = next(self.at).v3
\n	local to = next(self.to).v3
\n	self.line = e.util.create_line(at, to - at, parent)
\nend
\n
\nfunction Jump:update()
\n	local at = next(self.at).v3
\n	local to = next(self.to).v3
\n	self.line.Size = Vector3.new(0.05, 0.05, (to - at).Magnitude)
\n	self.line.CFrame = CFrame.new((at + to) / 2, to)
\nend
\n
\nfunction Jump:destroy()
\n	if not self.line then
\n		return
\n	end
\n	if self.line.Parent ~= nil then
\n		self.line:Destroy()
\n	end
\n	self.line = nil
\nend
\n
\nreturn setmetatable(Jump, Action_MT)"
local descendantModuleScript16 = Instance.new("ModuleScript", descendantModuleScript15)
descendantModuleScript16.Name = "config"
descendantModuleScript16.Source = "-- Polaris-Nav, advanced pathfinding as a library and service
\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer
\n-- tyler@hoyerz.com
\n--
\n-- This program is free software; you can redistribute it and/or
\n-- modify it under the terms of the GNU Lesser General Public
\n-- License as published by the Free Software Foundation; either
\n-- version 3 of the License, or (at your option) any later version.
\n--
\n-- This program is distributed in the hope that it will be useful,
\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of
\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\n-- Lesser General Public License for more details.
\n--
\n-- You should have received a copy of the GNU General Public License
\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.
\n
\nlocal mode = 'dev'
\n
\nreturn {
\n	DEFAULT_COLOR = Color3.new(0.4, 0.8, 0.4);
\n	DEFAULT_TRANS = 0.5;
\n
\n	SELECTED_COLOR = Color3.new(0.8, 0.4, 0.4);
\n	SELECTED_TRANS = 0;
\n
\n	HOVERED_COLOR = Color3.new(0.4, 0.4, 0.8);
\n
\n	DEFAULT_CONN_COLOR = Color3.new(0.4, 0.4, 0.8);
\n
\n	DIST_SAME_VERT = 0.01;
\n
\n	url = 'http://' .. mode .. '.Polaris-Nav.com/';
\n}"
local descendantModuleScript17 = Instance.new("ModuleScript", descendantModuleScript16)
descendantModuleScript17.Name = "format"
descendantModuleScript17.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\n\n\n\n\nlocal Ref_MT = {};\nlocal F = {\n	_VERSION = 3;\n	ID = {};\n	V3 = {};\n	Byte = {};\n	Double = {};\n	Int = {};\n	Int64 = {};\n	String = {};\n	Any = {};\n	Bool = {};\n	Ref = {};\n}\nsetmetatable(F.Ref, Ref_MT);\n\nfunction F.map(k_format, v_format)\n	return {\n		type = 'map';\n		k_format = k_format;\n		v_format = v_format;\n	}\nend\n\nfunction F.list(v_format, key)\n	return {\n		type = 'list';\n		v_format = v_format;\n		key = key;\n	}\nend\n\nfunction F.array(len, v_format, key)\n	return {\n		type = 'array';\n		v_format = v_format;\n		len = len;\n		key = key;\n	}\nend\n\nfunction F.union(...)\n	return {\n		type = 'union';\n		...\n	}\nend\n\nfunction F.struct(fields)\n	return {\n		type = 'struct';\n		fields = fields\n	}\nend\n\nfunction F.konst(value, v_format, is_serialized)\n	return {\n		type = 'konst';\n		value = value;\n		v_format = v_format;\n		is_serialized = is_serialized;\n	}\nend\n\nfunction F.save(name, v_format)\n	return {\n		type = 'save';\n		name = name;\n		v_format = v_format;\n	}\nend\n\nfunction F.compat(func)\n	return {\n		type = 'compat';\n		func = func;\n	}\nend\n\nfunction F.enable_if(cond, v_format)\n	return {\n		type = 'enable_if';\n		cond = cond;\n		v_format = v_format;\n	}\nend\n\nfunction F.format(name, t)\n	t.name = name\n	e[name].format = t\nend\n\nfunction F.new(name, t)\n	t.name = name\n	F[name] = t\nend\n\nfunction F.GE_VER(ver, on_true, on_false)\n	return F.compat(function(ctx)\n		if ctx.version >= ver then\n			return on_true\n		else\n			return on_false\n		end\n	end)\nend\n\nfunction Ref_MT:__index(name)\n	local v = {\n		type = 'ref';\n		of = name;\n	}\n	self[name] = v\n	return v\nend\n\nF.new('Challenge', F.struct{\n	{signature = F.array(16, F.Byte)};\n	{issued = F.Int64};\n	{difficulty = F.Byte};\n	{K00 = F.Int};\n	{K01 = F.Int};\n	{K10 = F.Int};\n	{K11 = F.Int};\n})\n\nF.new('Solution', F.struct{\n	{x = F.Int};\n	{y = F.Int};\n})\n\nreturn F"
local descendantModuleScript18 = Instance.new("ModuleScript", descendantModuleScript17)
descendantModuleScript18.Name = "http"
descendantModuleScript18.Source = "-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nlocal e = require(script.Parent)\n\nlocal http = game:GetService 'HttpService'\n\nlocal api = {}\n\nlocal timeout = 120\nlocal inf = math.huge\n\nlocal ERR_TIMED_OUT = 'Request timed out at %d seconds.'\nlocal ERR_LATE = 'Response arrived late (after %d seconds).'\nlocal ERR_HTTP = 'Request received HTTP %d %s \"%s\"'\nlocal ERR_RBX = 'Request received an error: \"%s\"'\n\nlocal LL = {}\nLL.prev = LL\nLL.next = LL\n\nlocal Request = {}\n\n-- Default error handler. May be called multiple times as errors happen.\nfunction Request:default_throw(args)\n	-- Emit if late\n	if not self.is_active then\n		local flight_time = self.finish_t - self.start_t\n		if self.success == nil then\n			e.warn(ERR_TIMED_OUT:format(flight_time))\n		else\n			e.warn(ERR_LATE:format(flight_time))\n		end\n	end\n\n	-- Emit if there was an error response\n	local r = self.response\n	if self.success then\n		-- lua error after request completed\n		if r.Success then\n			e.warn(self.msg)\n		-- HTTP network error\n		elseif r.StatusCode == 401 and r.Body == \"Session has expired\" then\n			local auth = e.store:getState().auth\n			return api.refresh {\n				token = auth.token;\n				id = auth.UserId;\n				session = auth.session;\n			}:Then(function (p, session)\n				e.set_session {\n					session = session;\n				}\n				self.predecessor.args.Headers.session = session\n				self:Stop()\n				return self.predecessor:RepeatAsync()\n			end)\n		else\n			e.warn(ERR_HTTP:format(\n				r.StatusCode,\n				r.StatusMessage,\n				r.Body\n			))\n		end\n	-- Roblox network error\n	elseif self.success == false then\n		e.warn(ERR_RBX:format(r))\n\n	-- lua errors before request was sent\n	else\n		e.warn(self.msg)\n	end\n\n	-- Emit where the request was made\n	print(self.traceback)\n\n	-- Continue additional error handlers\n	return self:Continue(args, self.msg)\nend\n\n-- Sends a request and waits for the response\nfunction Request:exec()\n	-- enqueue the request\n	self.next = LL\n	self.prev = LL.prev\n	self.next.prev = self\n	self.prev.next = self\n\n	-- send the request\n	self.start_t = tick()\n\n	self.success, self.response = pcall(http.RequestAsync, http, self.args)\n	self.finish_t = tick()\n\n\n\n	if self.is_active then\n		self.prev.next = self.next\n		self.next.prev = self.prev\n	elseif not self.args.accept_late then\n		return self:Throw()\n	end\n\n	if self.success and self.response.Success then\n		return self:Continue()\n	else\n		return self:Throw()\n	end\nend\n\nlocal function encode_solution(s)\n	e:load 'save_data'\n\n	local s_buf = {}\n	e.util.save(s_buf, s, e.format.Solution, {})\n	s = e.base64.encode_str(table.concat(s_buf))\n\n	return s\nend\n\nlocal function decode_challenge(c)\n	e:load 'load_data'\n	return e.util.load(e.base64.decode_str(c),\n		1, e.format.Challenge, {}\n	)\nend\n\n-- Create, enqueue, and send a new request\nlocal function req(args)\n	local req = setmetatable({\n		promise = nil;\n		success = nil;\n		response = nil;\n		args = args;\n		next = nil;\n		prev = nil;\n		start_t = inf;\n		is_active = true;\n		traceback = debug.traceback(nil, 2);\n	}, Request)\n\n	-- Promise for handling errors / responses\n	req.promise = e.promise(req)\n	:Then(Request.exec)\n	:Else(Request.default_throw)\n\n	return req.promise\nend\n\nfunction api:get_challenge()\n	return req {\n		Url = e.CFG.url .. '/v1/challenge';\n		Method = 'GET';\n	}\n	:Then(function(self)\n		local body = http:JSONDecode(self.response.Body)\n		local challenge = decode_challenge(body.challenge)\n		return self:Continue(challenge)\n	end)\nend\n\nfunction api:create_account()\n	return req {\n		Url = e.CFG.url .. '/v1/account';\n		Method = 'POST';\n		Headers = {\n			session = self.session;\n		};\n		Body = http:JSONEncode {\n			name = self.name;\n		};\n	}:Then(function(self)\n		local body = http:JSONDecode(self.response.Body)\n		return self:Continue(body.id)\n	end)\nend\n\nfunction api:link()\n	self.solution = encode_solution(self.solution)\n	return req {\n		Url = e.CFG.url .. '/v1/account/' .. self.id .. '/link';\n		Method = 'POST';\n		Headers = {\n			solution = self.solution;\n		};\n		Body = http:JSONEncode {\n			code = self.code;\n		};\n	}:Then(function(self)\n		local body = http:JSONDecode(self.response.Body)\n		return self:Continue {\n			token = body.token;\n			session = body.session;\n		}\n	end)\nend\n\nfunction api:login()\n	self.solution = encode_solution(self.solution)\n	return req {\n		Url = e.CFG.url .. '/v1/account/' .. self.id;\n		Method = 'POST';\n		Headers = {\n			solution = self.solution;\n		};\n		Body = http:JSONEncode {\n			token = self.token;\n		};\n	}:Then(function(self)\n		local body = http:JSONDecode(self.response.Body)\n		return self:Continue(body.session)\n	end)\nend\n\nfunction api:refresh()\n	return req {\n		Url = e.CFG.url .. '/v1/account/' .. self.id .. '/refresh';\n		Method = 'POST';\n		Headers = {\n			session = self.session;\n		};\n		Body = http:JSONEncode {\n			token = self.token;\n		};\n	}:Then(function(self)\n		local body = http:JSONDecode(self.response.Body)\n		return self:Continue(body.session)\n	end)\nend\n\nfunction api:generate()\n	e:load 'mesh_save'\n	local F = e.format\n	local util = e.util\n	local data = {}\n	util.save(data, {\n		params = self.params;\n		mesh = self.mesh;\n	}, F.MeshReq, {})\n	local signature = 'Polaris-Nav'\n	return req(setmetatable({\n		Url = e.CFG.url .. '/v1/generate';\n		Method = 'POST';\n		Headers = {\n			session = self.session;\n		};\n		Body = signature .. util.encode(table.concat(data));\n	}, {\n		__index = {\n			accept_late = true;\n		}\n	}))\n	:Then(function(self)\n		e.info 'Generation job submitted.'\n\n		local res = self.response\n		local data = res.Body\n		if data:sub(1, #signature) ~= signature then\n			e.warn 'The received file is not a mesh'\n			return\n		end\n\n		e:load 'mesh_load'\n		data = util.decode(data:sub(#signature + 1, -1))\n		if data == nil then\n			e.warn 'Unable to load the received mesh. This is likely a bug.'\n			return\n		end\n\n		e.info 'Mesh Received.'\n		local save = util.load(data, 1, F.MeshSave, {})\n		local v = save.version\n		if v < F._VERSION then\n			return e.warn(\n				'The received mesh is in an older version format.'\n					.. ' Server is v' .. v\n					.. ' while client is v' .. F._VERSION)\n		elseif v > F._VERSION then\n			return e.warn(\n				'The received mesh is in a newer version format.'\n					.. ' Server is v' .. v\n					.. ' while client is v' .. F._VERSION)\n		end\n\n		local nonconvex = {}\n		for i, surface in ipairs(save.mesh.surfaces) do\n			if not surface:is_convex() then\n				nonconvex[#nonconvex + 1] = i\n			end\n		end\n		if #nonconvex > 0 then\n			e.warn('Received mesh contains non-convex surfaces. Left unfixed, these will cause errors while finding the ground, and some connections to not exist and pathfinding to silently fail. These surfaces will appear red until fixed. The nonconvex surfaces\' IDs are: ' .. table.concat(nonconvex, ', '))\n		end\n\n		save.mesh.Visible = true\n		e.addMesh {\n			mesh = save.mesh;\n		}\n	end)\nend\n\nfunction api:get_credits()\n	return req {\n		Url = e.CFG.url .. '/v1/account/' .. self.id .. '/credits';\n		Method = 'GET';\n		Headers = {\n			session = self.session;\n		};\n	}:Then(function(self)\n		local body = http:JSONDecode(self.response.Body)\n		return self:Continue(body.credits)\n	end)\nend\n\nfunction api:add_credits()\n	return req {\n		Url = e.CFG.url .. '/v1/account/' .. self.id .. '/credits';\n		Method = 'PATCH';\n		Headers = {\n			session = self.session;\n		};\n		Body = http:JSONEncode {\n			credits = self.credits\n		}\n	}:Then(function(self)\n		local body = http:JSONDecode(self.response.Body)\n		return self:Continue(body.credits)\n	end)\nend\n\nfunction api:get_account()\n	return req {\n		Url = e.CFG.url .. '/v1/roblox/' .. self.rbx_id;\n		Method = 'GET';\n		Headers = {\n			session = self.session;\n		};\n	}:Then(function(self)\n		local body = http:JSONDecode(self.response.Body)\n		return self:Continue(body.id)\n	end)\nend\n\nfunction api:add_roblox()\n	return req {\n		Url = e.CFG.url .. '/v1/account/' .. self.id .. '/roblox';\n		Method = 'PUT';\n		Headers = {\n			session = self.session;\n		};\n		Body = http:JSONEncode {\n			rbx_id = tostring(self.rbx_id)\n		};\n	}\nend\n\nfunction api:begin_link()\n	return req {\n		Url = e.CFG.url .. '/v1/account/' .. self.id .. '/link';\n		Method = 'GET';\n		Headers = {\n			session = self.session;\n		};\n	}:Then(function(self)\n		local body = http:JSONDecode(self.response.Body)\n		return self:Continue(body.code)\n	end)\nend\n\n-- Event loop for timing out requests\ntask.spawn(function()\n	while true do\n		local t = tick()\n		local cur = LL.next\n		while cur ~= LL and t - cur.start_t > timeout do\n			cur.is_active = false\n			cur.promise:ThrowAsync()\n			cur = cur.next\n		end\n		LL.next = cur\n		cur.prev = LL\n\n		wait()\n	end\nend)\n\nreturn api\n"
local descendantModuleScript19 = Instance.new("ModuleScript", descendantModuleScript18)
descendantModuleScript19.Name = "ieee754"
descendantModuleScript19.Source = "-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n-- IEEE 754 double to binary\n-- Does not support:\n-- 	- signed zeros (treated as positive zero)\n-- 	- NaNs (all types treated as quiet NaNs with payload = 1, 0/0 in Lua)\n-- Both unsupported cases are due to being unable\n-- distingush between the numbers in Lua.\n\n-- encodings for special cases\nlocal  inf = string.char(0x7F, 0xF0, 0, 0, 0, 0, 0, 0)\nlocal ninf = string.char(0xFF, 0xF0, 0, 0, 0, 0, 0, 0)\nlocal qnan = string.char(0x7F, 0xF8, 0, 0, 0, 0, 0, 1)\nlocal nil_nan = string.char(0x7F, 0xF8, 0, 0, 0, 0, 0, 2)\n\n-- converts a 16-bit integer\nlocal function int2bytes(x, bytes)\n	for i = 2, 1, -1 do\n		local byte = x % 256\n		x = (x - byte) / 256\n		bytes[i] = byte\n	end\nend\n\n-- converts a 7 byte fraction (6.5 is used in IEEE 754)\nlocal function fraction2bytes(x, bytes)\n	for i = 2, 8 do\n		x = x * 256\n		local f = x % 1\n		bytes[i] = x - f\n		x = f\n	end\nend\n\n-- converts 6 bytes into a fraction as defined in IEE 754\nlocal function bytes2fraction(bytes)\n	local f = 0\n	for i = 8, 3, -1 do\n		f = (f + bytes[i]) / 256\n	end\n	return f\nend\n\nlocal zero = string.char(0, 0, 0, 0, 0, 0, 0, 0)\nlocal function d2b(x)\n	if type(x) ~= 'number' then\n		return nil_nan\n	end\n\n	local _x = x\n	if math.abs(x) == math.huge then\n		return x < 0 and ninf or inf\n	elseif x ~= x then\n		return qnan\n	elseif x == 0 then\n		return zero\n	end\n\n	local bytes = {0, 0, 0, 0, 0, 0, 0, 0}\n	local e = math.floor(math.log(math.abs(x), 2))\n	int2bytes((e + 1023) * 16, bytes)\n\n	-- does not preserve signed 0's\n	if x < 0 then\n		bytes[1] = bytes[1] + 128\n		x = math.abs(x)\n	end\n\n	local upper = bytes[2]\n	fraction2bytes((x / 2^e - 1) / 16, bytes)\n	bytes[2] = bytes[2] + upper\n\n	return string.char(unpack(bytes))\nend\n\nlocal l_float = {\n	[ inf] = {math.huge};\n	[ninf] = {-math.huge};\n	[qnan] = {0/0};\n	[nil_nan] = {nil};\n}\nlocal function b2d(b)\n	if l_float[b] then\n		return l_float[b][1]\n	end\n\n	local bytes = {b:byte(1, #b)}\n\n	local e_u = bytes[1] % 128\n	local f_u = bytes[2] % 16\n\n	local e = e_u * 16 + (bytes[2] - f_u) / 16\n\n	local f = bytes2fraction(bytes)\n	f = (f + f_u) / 16\n\n	-- allow subnormals\n	local y\n	if e > 0 then\n		y = 2^(e-1023) * (1 + f)\n	elseif f == 0 then\n		y = 0\n	else\n		y = 2^-1022 * f\n	end\n\n	-- signed floats\n	if bytes[1] - e_u == 128 then\n		y = -y\n	end\n\n	return y\nend\n\nreturn {\n	double2bin = d2b;\n	bin2double = b2d;\n}"
local descendantModuleScript20 = Instance.new("ModuleScript", descendantModuleScript19)
descendantModuleScript20.Name = "load_data"
descendantModuleScript20.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\n\n\nlocal F = e.format\nlocal util = e.util\n\n\nutil.b2d = e.ieee754.bin2double\n\n\nfunction util.b2i(b)\n	local bytes = {b:byte(1, #b)}\n	local x = 0\n	for i = 4, 1, -1 do\n		x = x * 256\n		x = x + bytes[i]\n	end\n\n\n\n	return x\nend\n\nfunction util.b2i64(b)\n	local bytes = {b:byte(1, #b)}\n	local x = 0\n	for i = 8, 1, -1 do\n		x = x * 256\n		x = x + bytes[i]\n	end\n\n\n\n	return x\nend\n\nfunction util.b2v(b)\n	return Vector3.new(\n		util.b2d(b:sub(1, 8)),\n		util.b2d(b:sub(9, 16)),\n		util.b2d(b:sub(17, 24))\n	)\nend\n\nfunction util.read_i(s, i)\n	return util.b2i(s:sub(i, i + 3)), i + 4\nend\n\nfunction util.read_i64(s, i)\n	return util.b2i64(s:sub(i, i + 7)), i + 8\nend\n\nfunction util.read_d(s, i)\n	return util.b2d(s:sub(i, i + 7)), i + 8\nend\n\nfunction util.read_v(s, i)\n	return util.b2v(s:sub(i, i + 23)), i + 24\nend\n\nfunction util.read_t(s, i)\n	return s:sub(i, i):byte(), i + 1\nend\n\nfunction util.read_s(s, i)\n	local n\n	n, i = util.read_i(s, i)\n	local si = i\n	i = i + n\n	local str = s:sub(si, i - 1)\n\n	return str, i\nend\n\nfunction util.read_a(s, i)\n	local ty\n	ty, i = util.read_t(s, i)\n	if ty == 0 then\n\n		return util.read_s(s, i)\n	elseif ty == 1 then\n\n		return util.read_d(s, i)\n	else\n		error('Received unknown field type: ' .. tostring(ty))\n	end\nend\n\nfunction util.decode(value)\n	e:load 'zero_encoding'\n	return e.LibDeflate:DecompressDeflate(util.decode_zeros(value))\nend\n\nfunction util.decode_params(data, i)\n	local fields = {}\n	local n\n	n, i = util.read_i(data, i)\n	for j = 1, n do\n		local name, value\n		name, i = util.read_s(data, i)\n		value, i = util.read_a(data, i)\n		fields[name] = value\n	end\n	return fields, i\nend\n\nfunction F.String:load(data, i)\n	return util.read_s(data, i)\nend\nfunction F.Bool:load(data, i)\n	local b = data:sub(i, i)\n	i = i + 1\n	return b == string.char(1), i\nend\nfunction F.V3:load(data, i)\n	return util.read_v(data, i)\nend\n\nfunction F.Byte:load(data, i)\n	return data:sub(i, i):byte(), i + 1\nend\n\nfunction F.Double:load(data, i)\n	return util.read_d(data, i)\nend\n\nfunction F.Int:load(data, i)\n	return util.read_i(data, i)\nend\n\nfunction F.Int64:load(data, i)\n	return util.read_i64(data, i)\nend\n\nfunction F.Any:load(data, i)\n	return util.read_a(data, i)\nend\n\nfunction util.load(data, i, format, context)\n	if not format then\n		return\n	end\n	\n	-- custom types have a \"format\" property\n	local class\n	if format.format then\n		class = format\n		format = format.format\n	end\n\n\n\n	local obj\n	if format == F.ID then\n		obj = #context[#context] + 1\n	elseif format.type then\n		if format.type == 'compat' then\n			obj, i = util.load(data, i, format.func(context), context)\n		elseif format.type == 'ref' then\n			local id\n			id, i = util.read_i(data, i)\n			obj = context[format.of][id]\n		elseif format.type == 'konst' then\n			if format.is_serialized then\n				obj, i = util.load(data, i, format.v_format, context)\n			else\n				obj = format.value\n			end\n		elseif format.type == 'save' then\n			obj, i = util.load(data, i, format.v_format, context)\n			context[format.name] = obj\n		elseif format.type == 'enable_if' then\n			if format.cond(data, i, context) then\n				obj, i = util.load(data, i, format.v_format, context)\n			end\n		elseif format.type == 'union' then\n			obj = {}\n			for j, v_format in ipairs(format) do\n				context.obj = obj\n				obj, i = util.load(data, i, v_format, context)\n			end\n\n		else\n			obj = context.obj\n			if obj then\n				context.obj = nil\n			else\n				obj = {}\n			end\n\n			if format.key then\n				context[format.key] = obj\n			end\n			if format.type == 'struct' then\n				for j, field in ipairs(format.fields) do\n					local k, v_format = next(field)\n\n					obj[k], i = util.load(data, i, v_format, context)\n				end\n			elseif format.type == 'array' then\n				local v_format = format.v_format\n				for j = 1, format.len do\n					obj[j], i = util.load(data, i, v_format, context)\n				end\n			else\n				local n\n				n, i = util.read_i(data, i)\n				local stack_id = #context + 1\n				context[stack_id] = obj\n				if format.type == 'list' then\n					local v_format = format.v_format\n					for j = 1, n do\n						obj[j], i = util.load(data, i, v_format, context)\n					end\n				elseif format.type == 'map' then\n					local k_format = format.k_format\n					local v_format = format.v_format\n					for j = 1, n do\n						local k, v\n						k, i = util.load(data, i, k_format, context)\n						if k ~= nil then\n							v, i = util.load(data, i, v_format, context)\n							obj[k] = v\n\n						end\n					end\n				else\n					print('unknown format type:', format.type)\n				end\n				context[stack_id] = nil\n			end\n		end\n	end\n\n	if class and class.MT then\n		setmetatable(obj, class.MT)\n	end\n\n	if format.load then\n\n\n		obj, i = format.load(obj, data, i, context)\n\n	end\n\n	return obj, i\nend\n\nreturn true"
local descendantModuleScript21 = Instance.new("ModuleScript", descendantModuleScript20)
descendantModuleScript21.Name = "mesh_format"
descendantModuleScript21.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\n\n\nlocal Point = e.Point\nlocal Surface = e.Surface\nlocal Connection = e.Connection\nlocal CConnection = e.CConnection\nlocal Mesh = e.Mesh\n\nlocal F = e.format\n\nlocal Barrier = F.union(Surface, F.struct {\n	{is_barrier = F.konst(true, F.bool, false)}\n})\n\nF.format('Point', F.struct{\n	{id = F.ID};\n	{v3 = F.V3};\n	{ptype = F.Byte};\n})\nF.new('PointSight', F.map(F.Ref.Points, F.Double))\nF.format('Surface', F.union(\n	F.list(F.Ref.Points),\n	F.struct{\n		{id = F.ID};\n		{c_conns = F.map(F.Ref.Points, F.Ref.CConns)};\n	}\n))\nF.format('Connection', F.struct{\n	{action = F.Int};\n	{fromID = F.Int};\n	{toID = F.Int};\n	{i1 = F.Int};\n	{i2 = F.Int};\n	{j1 = F.Int};\n	{j2 = F.Int};\n	{t1 = F.Double};\n	{t2 = F.Double};\n	{u1 = F.Double};\n	{u2 = F.Double};\n})\nF.format('CConnection', F.struct{\n	{type = F.String};\n	{bidirectional = F.Bool};\n	{at = F.map(F.Ref.Points, F.konst(true, F.Bool, false))};\n	{to = F.map(F.Ref.Points, F.konst(true, F.Bool, false))};\n})\nF.format('Mesh', F.struct{\n	{Name = F.String};\n	{Visible = F.Bool};\n	{points = F.list(Point, 'Points')};\n	{c_conns = F.GE_VER(2, F.list(CConnection, 'CConns'))};\n	{surfaces = F.list(Surface, 'Surfaces')};\n	{barriers = F.GE_VER(3, F.list(Barrier, 'Barriers'))};\n	{connections = F.list(Connection)};\n})\n\nF.new('MeshSave', F.struct{\n	{version = F.save(\n		'version',\n		F.konst(F._VERSION, F.Int, true)\n	)};\n	{mesh = Mesh};\n})\nF.new('MeshReq', F.struct{\n	{version = F.save(\n		'version',\n		F.konst(F._VERSION, F.Int, true)\n	)};\n	{params = F.map(F.String, F.Any)};\n	{mesh = Mesh};\n})\n\nreturn true"
local descendantModuleScript22 = Instance.new("ModuleScript", descendantModuleScript21)
descendantModuleScript22.Name = "mesh_from_parts"
descendantModuleScript22.Source = "-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nlocal e = require(script.Parent)\n\nlocal Point = e.Point\nlocal Surface = e.Surface\nlocal Mesh = e.Mesh\n\nlocal U = Point.UNKNOWN\n\nfunction Surface:from_part(part)\n	local x, y, z,\n	xx, yx, zx,\n	xy, yy, zy,\n	xz, yz, zz = part.CFrame:components()\n	local size = part.Size\n	local xa = Vector3.new(xx, xy, xz) * size.x / 2\n	local ya = Vector3.new(yx, yy, yz) * size.y / 2\n	local za = Vector3.new(zx, zy, zz) * size.z / 2\n	local p = Vector3.new(x, y, z)\n\n	if part:IsA 'WedgePart' then\n		local pts = {\n			Point.new(p+xa+ya+za, U);\n			nil; --Point.new(p+xa+ya-za, U);\n			Point.new(p+xa-ya+za, U);\n			Point.new(p+xa-ya-za, U);\n			Point.new(p-xa+ya+za, U);\n			nil; --Point.new(p-xa+ya-za, U);\n			Point.new(p-xa-ya+za, U);\n			Point.new(p-xa-ya-za, U);\n		}\n		\n		return\n			-- positive x\n			self.new{pts[1], pts[4], pts[3]},\n			\n			-- negative x\n			self.new{pts[8], pts[5], pts[7]},\n			\n			-- positive y\n			self.new{pts[1], pts[5], pts[8], pts[4]},\n		\n			-- negative y\n			self.new{pts[8], pts[7], pts[3], pts[4]},\n\n			-- positive z\n			self.new{pts[1], pts[3], pts[7], pts[5]}\n\n			-- negative z\n			-- self.new{pts[8], pts[4], pts[2], pts[6]}\n	elseif part:IsA 'CornerWedgePart' then\n		local pts = {\n			nil; --Point.new(p+xa+ya+za, U);\n			Point.new(p+xa+ya-za, U);\n			Point.new(p+xa-ya+za, U);\n			Point.new(p+xa-ya-za, U);\n			nil; --Point.new(p-xa+ya+za, U);\n			nil; --Point.new(p-xa+ya-za, U);\n			Point.new(p-xa-ya+za, U);\n			Point.new(p-xa-ya-za, U);\n		}\n		\n		return\n			-- positive x\n			self.new{pts[2], pts[4], pts[3]},\n			\n			-- negative x\n			self.new{pts[8], pts[2], pts[7]},\n			\n			-- positive y\n			-- self.new{pts[1], pts[5], pts[6], pts[2]},\n		\n			-- negative y\n			self.new{pts[8], pts[7], pts[3], pts[4]},\n\n			-- positive z\n			self.new{pts[2], pts[3], pts[7]},\n\n			-- negative z\n			self.new{pts[8], pts[4], pts[2]}\n	elseif part:IsA 'Part' or part:IsA 'TrussPart' or part:IsA 'VehicleSeat' then\n		local pts = {\n			Point.new(p+xa+ya+za, U);\n			Point.new(p+xa+ya-za, U);\n			Point.new(p+xa-ya+za, U);\n			Point.new(p+xa-ya-za, U);\n			Point.new(p-xa+ya+za, U);\n			Point.new(p-xa+ya-za, U);\n			Point.new(p-xa-ya+za, U);\n			Point.new(p-xa-ya-za, U);\n		}\n		\n		return\n			-- positive x\n			self.new{pts[1], pts[2], pts[4], pts[3]},\n			\n			-- negative x\n			self.new{pts[8], pts[6], pts[5], pts[7]},\n			\n			-- positive y\n			self.new{pts[1], pts[5], pts[6], pts[2]},\n		\n			-- negative y\n			self.new{pts[8], pts[7], pts[3], pts[4]},\n\n			-- positive z\n			self.new{pts[1], pts[3], pts[7], pts[5]},\n\n			-- negative z\n			self.new{pts[8], pts[4], pts[2], pts[6]}\n	end\nend\n\nlocal max_walk_angle = 89\nlocal min_normal_y = math.cos(math.rad(max_walk_angle))\nfunction Mesh.from_parts(parts)\n	local mesh = Mesh.new()\n	for i, part in ipairs(parts) do\n		for j, surface in ipairs{e.Surface:from_part(part)} do\n			for k, point in ipairs(surface) do\n				if not point.id then\n					mesh:add_point(point)\n				end\n			end\n			if surface.normal.Y >= min_normal_y then\n				mesh:add_surface(surface)\n			else\n				mesh:add_barrier(surface)\n			end\n		end\n	end\n	return mesh\nend\n\nreturn true"
local descendantModuleScript23 = Instance.new("ModuleScript", descendantModuleScript22)
descendantModuleScript23.Name = "mesh_from_save"
descendantModuleScript23.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service
\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer
\n-- tyler@hoyerz.com
\n--
\n-- This program is free software; you can redistribute it and/or
\n-- modify it under the terms of the GNU Lesser General Public
\n-- License as published by the Free Software Foundation; either
\n-- version 3 of the License, or (at your option) any later version.
\n--
\n-- This program is distributed in the hope that it will be useful,
\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of
\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\n-- Lesser General Public License for more details.
\n--
\n-- You should have received a copy of the GNU General Public License
\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.
\n\n
\n\nlocal e = require(script.Parent)
\n\n
\nlocal F = e.format
\nlocal util = e.util
\nlocal Point = e.Point
\nlocal Surface = e.Surface
\nlocal Connection = e.Connection
\nlocal CConnection = e.CConnection
\nlocal Mesh = e.Mesh
\n
\nutil.b2d = e.ieee754.bin2double;
\n
\nfunction util.b2i(b)
\n	local bytes = {b:byte(1, #b)}
\n	local x = 0
\n	for i = 1, 4 do
\n		x = x * 256
\n		x = x + bytes[i]
\n	end
\n	return x
\nend
\n
\nfunction util.b2v(b)
\n	return Vector3.new(
\n		util.b2d(b:sub(1, 8)),
\n		util.b2d(b:sub(9, 16)),
\n		util.b2d(b:sub(17, 24))
\n	)
\nend
\n
\nfunction util.read_i(s, i)
\n	return util.b2i(s:sub(i, i + 3)), i + 4
\nend
\n
\nfunction util.read_d(s, i)
\n	return util.b2d(s:sub(i, i + 7)), i + 8
\nend
\n
\nfunction util.read_v(s, i)
\n	return util.b2v(s:sub(i, i + 23)), i + 24
\nend
\n
\nfunction util.read_t(s, i)
\n	return s:sub(i, i):byte(), i + 1
\nend
\n
\nfunction util.read_s(s, i)
\n	local n
\n	local t = {}
\n	for j = 1, i + 3 do
\n		t[j] = tostring(s:sub(j, j):byte())
\n	end
\n	n, i = util.read_i(s, i)
\n	local si = i
\n	i = i + n
\n	return s:sub(si, i - 1), i
\nend
\n
\nfunction util.read_a(s, i)
\n	local ty
\n	ty, i = util.read_t(s, i)
\n	if ty == 0 then
\n		return util.read_s(s, i)
\n	elseif ty == 1 then
\n		return util.read_d(s, i)
\n	else
\n		error('Received unknown field type: ' .. tostring(ty))
\n	end
\nend
\n
\nfunction util.decode(value)
\n	e:load 'zero_encoding'
\n	return e.LibDeflate:DecompressDeflate(util.decode_zeros(value))
\nend
\n
\nfunction util.decode_params(data, i)
\n	local fields = {}
\n	local n
\n	n, i = util.read_i(data, i)
\n	for j = 1, n do
\n		local name, value
\n		name, i = util.read_s(data, i)
\n		value, i = util.read_a(data, i)
\n		fields[name] = value
\n	end
\n	return fields, i
\nend
\n
\nfunction F.String:load(data, i)
\n	return util.read_s(data, i)
\nend
\nfunction F.Bool:load(data, i)
\n	local b = data:sub(i, i)
\n	i = i + 1
\n	return b == string.char(1), i
\nend
\nfunction F.V3:load(data, i)
\n	return util.read_v(data, i)
\nend
\n
\nfunction F.Byte:load(data, i)
\n	return data:sub(i, i):byte(), i + 1
\nend
\n
\nfunction F.Double:load(data, i)
\n	return util.read_d(data, i)
\nend
\n
\nfunction F.Int:load(data, i)
\n	return util.read_i(data, i)
\nend
\n
\nfunction F.Any:load(data, i)
\n	return util.read_a(data, i)
\nend
\n
\nfunction util.load(data, i, format, context)
\n	-- custom types have a \"format\" property
\n	local class
\n	if format.format then
\n		class = format
\n		format = format.format
\n	end
\n
\n\n
\n	local obj
\n	if format == F.ID then
\n		obj = #context[#context] + 1
\n	elseif format.type then
\n		if format.type == 'ref' then
\n			local id
\n			id, i = util.read_i(data, i)
\n			obj = context[format.of][id]
\n		elseif format.type == 'konst' then
\n			if format.is_serialized then
\n				obj, i = util.load(data, i, format.v_format, context)
\n			else
\n				obj = format.value
\n			end
\n		elseif format.type == 'save' then
\n			obj, i = util.load(data, i, format.v_format, context)
\n			context[format.name] = obj
\n		elseif format.type == 'enable_if' then
\n			if format.cond(data, i, context) then
\n				obj, i = util.load(data, i, format.v_format, context)
\n			end
\n		elseif format.type == 'union' then
\n			obj = {}
\n			for j, v_format in ipairs(format) do
\n				context.obj = obj
\n				obj, i = util.load(data, i, v_format, context)
\n			end
\n\n		else
\n			obj = context.obj
\n			if obj then
\n				context.obj = nil
\n			else
\n				obj = {}
\n			end
\n
\n			if format.key then
\n				context[format.key] = obj
\n			end
\n			if format.type == 'struct' then
\n				for j, field in ipairs(format.fields) do
\n					local k, v_format = next(field)
\n\n					obj[k], i = util.load(data, i, v_format, context)
\n				end
\n			else
\n				local n
\n				n, i = util.read_i(data, i)
\n				local stack_id = #context + 1
\n				context[stack_id] = obj
\n				if format.type == 'list' then
\n					local v_format = format.v_format
\n					for j = 1, n do
\n						obj[j], i = util.load(data, i, v_format, context)
\n					end
\n				elseif format.type == 'map' then
\n					local k_format = format.k_format
\n					local v_format = format.v_format
\n					for j = 1, n do
\n						local k, v
\n						k, i = util.load(data, i, k_format, context)
\n						if k ~= nil then
\n							v, i = util.load(data, i, v_format, context)
\n							obj[k] = v
\n\n						end
\n					end
\n				else
\n					print('unknown format type:', format.type)
\n				end
\n				context[stack_id] = nil
\n			end
\n		end
\n	end
\n
\n	if class and class.MT then
\n		setmetatable(obj, class.MT)
\n	end
\n
\n	if format.load then
\n\n\n		obj, i = format.load(obj, data, i, context)
\n\n	end
\n\n	return obj, i
\nend
\n
\nfunction Point.format:load(data, i, context)
\n	self.surfaces = {}
\n	self.lines_by_p = {}
\n	self.lines_by_s = {}
\n	self.sight, i = util.load(data, i, F.PointSight, context)
\n	for point, cost in next, self.sight do
\n		point.sight[self] = cost
\n	end
\n	return self, i
\nend
\n
\nfunction Mesh.format:load(data, i)
\n	local reflexes = {}
\n	self.reflexes = reflexes
\n	for i, p in ipairs(self.points) do
\n		if p.ptype >= Point.REFLEX then
\n			reflexes[p] = true
\n		end
\n	end
\n\n	self.octree = e.Octree.Octree(0, 0, 0, 10);
\n\n	return self, i
\nend
\n
\nfunction Surface.format:load(data, i, context)
\n	local a, b, c = self[1].v3, self[2].v3, self[3].v3
\n	self.normal = (c - a):Cross(b - a).Unit
\n	self.connections = {}
\n	self.adjacent = {}
\n	for i, p in ipairs(self) do
\n		p:add(self, i)
\n	end
\n	for p, c_conn in next, self.c_conns do
\n		p:add(self, c_conn)
\n	end
\n	return self, i
\nend
\n
\nfunction CConnection.format:load(data, i, context)
\n	local action = e[self.type]
\n	setmetatable(self, action.MT)
\n	if self.save then
\n		local str
\n		str, i = util.read_s(data, i)
\n		self:load(str)
\n	end
\n	return self, i
\nend
\n
\nfunction Mesh.load_dir(root)
\n	if root.ClassName ~= 'Folder' then
\n		return warn(root:GetFullName() .. ' is not a folder containing a saved mesh')
\n	end
\n
\n	local saves = {}
\n	for i, save in ipairs(root:GetChildren()) do
\n		local num = tonumber(save.Name)
\n		if save.ClassName == 'StringValue' and num then
\n			saves[num] = save.Value
\n		end
\n	end
\n	if #saves == 0 then
\n		return warn(root:GetFullName() .. ' has no save data')
\n	end
\n
\n	local data = util.decode(table.concat(saves))
\n	if not data then
\n		return warn(root:GetFullName() .. ': save appears to be corrupted')
\n	end
\n
\n	return util.load(data, 1, F.MeshSave, {}).mesh
\nend
\n
\nreturn true"
local descendantModuleScript24 = Instance.new("ModuleScript", descendantModuleScript23)
descendantModuleScript24.Name = "mesh_generate"
descendantModuleScript24.Source = "-- Polaris-Nav, advanced pathfinding as a library and service
\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer
\n-- tyler@hoyerz.com
\n--
\n-- This program is free software; you can redistribute it and/or
\n-- modify it under the terms of the GNU Lesser General Public
\n-- License as published by the Free Software Foundation; either
\n-- version 3 of the License, or (at your option) any later version.
\n--
\n-- This program is distributed in the hope that it will be useful,
\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of
\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\n-- Lesser General Public License for more details.
\n--
\n-- You should have received a copy of the GNU General Public License
\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.
\n
\nlocal e = require(script.Parent)
\n
\nlocal util = e.util
\nlocal Mesh = e.Mesh
\n
\nlocal signature = 'Polaris-Nav'
\n
\nfunction Mesh.generate(token, params, parts)
\n	e:load 'mesh_from_parts'
\n	local mesh = Mesh.from_parts(parts)
\n
\n	e:load 'mesh_to_save'
\n	local F = e.format
\n	local data = {}
\n	util.save(data, {
\n		params = params;
\n		mesh = mesh;
\n	}, F.MeshReq, {})
\n	local msg = signature .. util.encode(table.concat(data))
\n
\n	local response = e.http.req {
\n		path = 'v1/mesh/generate';
\n		msg = msg;
\n		token = token;
\n		accept_late = true;
\n		handler = function(res, node)
\n			if res then
\n				e.info 'Generation job submitted.'
\n
\n				if res.StatusCode == 200 then
\n					if not res.Body or res.Body == '' then
\n						e.warn 'Did not receive a response body. This is likely a bug.'
\n						return
\n					end
\n
\n					local data = res.Body
\n					if data:sub(1, #signature) ~= signature then
\n						e.warn 'The received file is not a mesh'
\n						return
\n					end
\n
\n					e:load 'mesh_save'
\n					data = util.decode(data:sub(#signature + 1, -1))
\n					if data == nil then
\n						e.warn 'Unable to load the received mesh. This is likely a bug.'
\n						return
\n					end
\n
\n					e.info 'Mesh Received.'
\n					e:load 'mesh_save'
\n					local save = util.load(data, 1, F.MeshSave, {})
\n					local v = save.version
\n					if v < F._VERSION then
\n						return e.warn(
\n							'The received mesh is in an older version format.'
\n								.. ' Server is v' .. v
\n								.. ' while client is v' .. F._VERSION)
\n					elseif v > F._VERSION then
\n						return e.warn(
\n							'The received mesh is in a newer version format.'
\n								.. ' Server is v' .. v
\n								.. ' while client is v' .. F._VERSION)
\n					end
\n
\n					save.mesh.Visible = true
\n					e.addMesh {
\n						mesh = save.mesh;
\n					}
\n				else
\n					e.warn(('Failed to generate mesh: %s %s %s')
\n						:format(res.StatusCode, res.StatusMessage, res.Body))
\n				end
\n			end
\n		end
\n	}
\nend
\n
\nreturn true"
local descendantModuleScript25 = Instance.new("ModuleScript", descendantModuleScript24)
descendantModuleScript25.Name = "mesh_line_of_sight"
descendantModuleScript25.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\n\n\nlocal util = e.util\nlocal Point = e.Point\nlocal Surface = e.Surface\nlocal Mesh = e.Mesh\n\nlocal UP = Vector3.new(0, 1, 0)\nlocal eps = 1e-7\n\nlocal function insert(t, k, v)\n	local cur = t[k]\n	if cur then\n		cur[#cur + 1] = v\n	else\n		t[k] = {v}\n	end\nend\n\nfunction Point:cache_line(other, surface)\n	insert(self.lines_by_p, other, surface)\n	insert(self.lines_by_s, surface, other)\nend\n\n\n\nfunction Point:line_of_sight(start_v3, goal_v3, v)\n	-- find path between the points\n	local s_neg, s_pos\n	local c_neg, c_pos\n	local search_lines = true\n	local d = goal_v3 - self.v3\n	for p, s in next, self.lines_by_p do\n		local u = (p.v3 - self.v3).Unit\n		local r = d - u.Unit:Dot(d)\n		if r.X * r.Z + r.Z * r.Z < 0.0001 then\n			return true\n		end\n\n		local sine = v:Cross(u).Y\n		local cos = v:Dot(u)\n		if sine < -eps then\n			if not c_neg or cos > c_neg then\n				c_neg = cos\n				s_neg = s\n			end\n		elseif sine > eps then\n			if not c_pos or cos > c_pos then\n				c_pos = cos\n				s_pos = s\n			end\n		elseif cos > 0 then\n			search_lines = false\n			if p:line_of_sight(start_v3, goal_v3, v) then\n				return true\n			end\n		end\n	end\n\n	if not (search_lines and s_neg and s_pos) then\n		return false\n	end\n\n	local s = s_neg[1]\n	if s ~= s_pos[1] and s ~= s_pos[2] then\n		s = s_neg[2]\n	end\n	if s then\n		return s:_line_of_sight(start_v3, goal_v3, v,\n			s:next_i(self.surfaces[s]))\n	end\n\n	return false\nend\n\nfunction Surface:_line_of_sight(start_v3, goal_v3, v, sid)\n	local prev_v3 = self[sid].v3\n	local i = self:next_i(sid)\n	while i ~= sid do\n		local p_v3 = self[i].v3\n		if v:Cross(p_v3 - start_v3).Y < 0 then\n			if (goal_v3 - prev_v3):Cross(p_v3 - prev_v3).Y >= 0 then\n				return true\n			end\n\n			local s = self.adjacent[i]\n			if s then\n				return s:line_of_sight(start_v3, goal_v3, v, self[i].surfaces[s])\n			else\n				return false\n			end\n		end\n		i = self:next_i(i)\n		prev_v3 = p_v3\n	end\n\n	return false\nend\n\nfunction Surface:line_of_sight(start_v3, goal_v3)\n	local v = goal_v3 - start_v3\n	if v.Magnitude < util.prec then\n		return true\n	end\n	for i, p in ipairs(self) do\n		if v:Cross(p.v3 - start_v3).Y > 0 then\n			return self:_line_of_sight(start_v3, goal_v3, v, i)\n		end\n	end\n\n	return false\nend\n\n\n\nfunction Surface:cache_lines()\n	local adj = self.adjacent\n	local prev = self[#self]\n	for i, p in ipairs(self) do\n		p:cache_line(prev, self)\n		prev:cache_line(p, self)\n\n		for s, sid in next, p.surfaces do\n			if s[s:next_i(sid)] == prev then\n				adj[i] = s\n				break\n			end\n		end\n\n		prev = p\n	end\nend\n\nfunction Mesh:get_visible(pos, surface)\n	local adj = {}\n	for reflex in next, self.reflexes do\n		if surface:line_of_sight(pos, reflex.v3) then\n\n			adj[reflex] = (pos - reflex.v3).Magnitude\n\n		end\n	end\n	return adj\nend\n\nfunction Mesh:cache_lines()\n	for i, s in ipairs(self.surfaces) do\n		s:cache_lines()\n	end\nend\n\nreturn true"
local descendantModuleScript26 = Instance.new("ModuleScript", descendantModuleScript25)
descendantModuleScript26.Name = "mesh_load"
descendantModuleScript26.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\n\n\ne:load 'mesh_format'\ne:load 'load_data'\n\nlocal F = e.format\nlocal util = e.util\n\nlocal Point = e.Point\nlocal Surface = e.Surface\nlocal Connection = e.Connection\nlocal CConnection = e.CConnection\nlocal Mesh = e.Mesh\n\nfunction Point.format:load(data, i, context)\n	self.surfaces = {}\n	self.lines_by_p = {}\n	self.lines_by_s = {}\n	self.sight, i = util.load(data, i, F.PointSight, context)\n	for point, cost in next, self.sight do\n		point.sight[self] = cost\n	end\n	return self, i\nend\n\nfunction Mesh.format:load(data, i)\n	local reflexes = {}\n	self.reflexes = reflexes\n	local is_reflex = Point.is_reflex\n	for i, p in ipairs(self.points) do\n		if is_reflex[p.ptype] then\n			reflexes[p] = true\n		end\n		local is_blocked = true\n		for s, id in pairs(p.surfaces) do\n			if not s.is_barrier then\n				is_blocked = false\n				break\n			end\n		end\n		if is_blocked then\n			p.ptype = Point.BLOCKED\n		end\n	end\n\n	self.octree = e.Octree.Octree(0, 0, 0, 10);\n\n	return self, i\nend\n\nfunction Surface.format:load(data, i, context)\n	local is_valid, normal = Surface.calc_normal(self)\n	if not is_valid then\n		warn 'unable to load a surface due to all points being on a line (invalid)'\n		return nil, i\n	end\n	self.normal = normal\n	self.connections = {}\n	self.adjacent = {}\n	for i, p in ipairs(self) do\n		p:add(self, i)\n	end\n	for p, c_conn in next, self.c_conns do\n		p:add(self, c_conn)\n	end\n	return self, i\nend\n\nfunction CConnection.format:load(data, i, context)\n	local action = e[self.type]\n	setmetatable(self, action.MT)\n	if self.save then\n		local str\n		str, i = util.read_s(data, i)\n		self:load(str)\n	end\n	return self, i\nend\n\nfunction Mesh.load_dir(root)\n	if root.ClassName ~= 'Folder' then\n		return warn(root:GetFullName() .. ' is not a folder containing a saved mesh')\n	end\n\n	local saves = {}\n	for i, save in ipairs(root:GetChildren()) do\n		local num = tonumber(save.Name)\n		if save.ClassName == 'StringValue' and num then\n			saves[num] = save.Value\n		end\n	end\n	if #saves == 0 then\n		return warn(root:GetFullName() .. ' has no save data')\n	end\n\n	local data = util.decode(table.concat(saves))\n	if not data then\n		return warn(root:GetFullName() .. ': save appears to be corrupted')\n	end\n\n	return util.load(data, 1, F.MeshSave, {}).mesh\nend\n\nreturn true"
local descendantModuleScript27 = Instance.new("ModuleScript", descendantModuleScript26)
descendantModuleScript27.Name = "mesh_save"
descendantModuleScript27.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\n\n\ne:load 'mesh_format'\ne:load 'save_data'\n\nlocal F = e.format\nlocal util = e.util\n\nlocal Point = e.Point\nlocal Surface = e.Surface\nlocal Connection = e.Connection\nlocal CConnection = e.CConnection\nlocal Mesh = e.Mesh\n\nlocal function a(to, str)\n	to[#to + 1] = str\n	if to.size then\n		to.size = to.size + #str\n	end\nend\n\nfunction Point.format:save(data, context)\n	local sight = {}\n	local id = self.id\n	for point, cost in next, self.sight do\n		if point.id <= id then\n			sight[point] = cost\n		end\n	end\n	return util.save(data, sight, F.PointSight, context)\nend\n\nfunction CConnection.format:save(data, context)\n	local action = e[self.type]\n	if self.save then\n		a(data, util.s2b(self:save()))\n	end\nend\n\n\n\nreturn true"
local descendantModuleScript28 = Instance.new("ModuleScript", descendantModuleScript27)
descendantModuleScript28.Name = "mesh_to_save"
descendantModuleScript28.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service
\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer
\n-- tyler@hoyerz.com
\n--
\n-- This program is free software; you can redistribute it and/or
\n-- modify it under the terms of the GNU Lesser General Public
\n-- License as published by the Free Software Foundation; either
\n-- version 3 of the License, or (at your option) any later version.
\n--
\n-- This program is distributed in the hope that it will be useful,
\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of
\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\n-- Lesser General Public License for more details.
\n--
\n-- You should have received a copy of the GNU General Public License
\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.
\n\n
\n\nlocal e = require(script.Parent)
\n\n
\nlocal F = e.format
\nlocal util = e.util
\nlocal Point = e.Point
\nlocal Surface = e.Surface
\nlocal Connection = e.Connection
\nlocal CConnection = e.CConnection
\nlocal Mesh = e.Mesh
\n
\nutil.d2b = e.ieee754.double2bin;
\n
\nlocal function a(to, str)
\n	to[#to + 1] = str
\n	if to.size then
\n		to.size = to.size + #str
\n	end
\nend
\n
\nfunction util.i2b(x)
\n	local bytes = {nil, nil, nil, nil}
\n	for i = 4, 1, -1 do
\n		local byte = x % 256
\n		x = (x - byte) / 256
\n		bytes[i] = byte
\n	end
\n\n	return string.char(table.unpack(bytes))
\n\nend
\n
\nfunction util.v2b(v)
\n	local s = table.concat {
\n		util.d2b(v.X),
\n		util.d2b(v.Y),
\n		util.d2b(v.Z)
\n	}
\n	return s
\nend
\n
\nfunction util.s2b(s)
\n	return util.i2b(#s) .. s
\nend
\n
\nfunction util.a2b(v)
\n	local ty = type(v)
\n	if ty == 'string' then
\n		return string.char(0) .. util.s2b(v)
\n	elseif ty == 'number' then
\n		return string.char(1) .. util.d2b(v)
\n	end
\nend
\n
\nfunction util.encode(value)
\n	e:load 'zero_encoding'
\n	return util.encode_zeros(e.LibDeflate:CompressDeflate(value, {level = 9}))
\nend
\n
\nfunction F.String:save(data)
\n	return a(data, util.s2b(self))
\nend
\nfunction F.Bool:save(data)
\n	return a(data, self
\n		and string.char(1)
\n		or string.char(0))
\nend
\nfunction F.V3:save(data)
\n	return a(data, util.v2b(self))
\nend
\n
\nfunction F.Byte:save(data)
\n	return a(data, string.char(self))
\nend
\n
\nfunction F.Double:save(data)
\n	return a(data, util.d2b(self))
\nend
\n
\nfunction F.Int:save(data)
\n	return a(data, util.i2b(self))
\nend
\n
\nfunction F.Any:save(data)
\n	return a(data, util.a2b(self))
\nend
\n
\nfunction util.save(data, obj, format, context)
\n	-- custom types have a \"format\" property
\n	format = format.format or format
\n
\n
\n\n
\n	if format.type then
\n		if format.type == 'ref' then
\n			a(data, util.i2b(obj.id))
\n		elseif format.type == 'konst' then
\n			if format.is_serialized then
\n				util.save(data, format.value, format.v_format, context)
\n			end
\n		elseif format.type == 'save' then
\n			util.save(data, obj, format.v_format, context)
\n		elseif format.type == 'enable_if' then
\n			util.save(data, obj, format.v_format, context)
\n		elseif format.type == 'union' then
\n			for j, v_format in ipairs(format) do
\n				util.save(data, obj, v_format, context)
\n			end
\n		else
\n			if format.type == 'struct' then
\n				for j, field in ipairs(format.fields) do
\n					local k, v = next(field)
\n\n					util.save(data, obj[k], v, context)
\n				end
\n			else
\n				local i, n = #data + 1, 0
\n				data[i] = ''
\n				if format.type == 'list' then
\n					local v_format = format.v_format
\n					n = #obj
\n					for i, v in ipairs(obj) do
\n						util.save(data, v, v_format, context)
\n					end
\n				elseif format.type == 'map' then
\n					local k_format = format.k_format
\n					local v_format = format.v_format
\n					for k, v in next, obj do
\n						n = n + 1
\n						util.save(data, k, k_format, context)
\n						util.save(data, v, v_format, context)
\n					end
\n				else
\n					print('unknown format type:', format.type)
\n				end
\n				data[i] = util.i2b(n)
\n			end
\n		end
\n	end
\n
\n	if format.save then
\n\n\n		format.save(obj, data, context)
\n	end
\n\n\nend
\n
\nfunction Point.format:save(data, context)
\n	local sight = {}
\n	local id = self.id
\n	for point, cost in next, self.sight do
\n		if point.id <= id then
\n			sight[point] = cost
\n		end
\n	end
\n	return util.save(data, sight, F.PointSight, context)
\nend
\n
\nfunction CConnection.format:save(data, context)
\n	local action = e[self.type]
\n	if self.save then
\n		a(data, util.s2b(self:save()))
\n	end
\nend
\n
\n\n
\nreturn true"
local descendantModuleScript29 = Instance.new("ModuleScript", descendantModuleScript28)
descendantModuleScript29.Name = "mesh_visualize"
descendantModuleScript29.Source = "-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nlocal e = require(script.Parent)\n\nlocal CS = game:GetService 'CollectionService'\n\nlocal util = e.util\nlocal Point = e.Point\nlocal Surface = e.Surface\nlocal Connection = e.Connection\nlocal Mesh = e.Mesh\n\nfunction util.create_point(pos, parent)\n	local p = Instance.new(\"Part\")\n	p.Archivable = false\n	p.Shape = Enum.PartType.Ball\n	p.FormFactor = Enum.FormFactor.Custom\n	p.BottomSurface = Enum.SurfaceType.Smooth\n	p.TopSurface = Enum.SurfaceType.Smooth\n	p.Anchored = true\n	p.Size = Vector3.new(1, 1, 1)\n	p.Position = pos\n	p.Locked = true\n	p.Parent = parent\n	return p\nend\n\nfunction util.create_line(pos, dir, parent)\n	local p = Instance.new(\"Part\")\n	p.Archivable = false\n	p.FormFactor = Enum.FormFactor.Custom\n	p.BottomSurface = Enum.SurfaceType.Smooth\n	p.TopSurface = Enum.SurfaceType.Smooth\n	p.Anchored = true\n	p.Color = Color3.new(0, 0, 0.8)\n	p.Size = Vector3.new(0.05, 0.05, dir.Magnitude)\n	p.CFrame = CFrame.new(pos + dir / 2, pos + dir)\n	p.Locked = true\n	p.Parent = parent\n	return p\nend\n\nlocal function spawnTrianglePart(parent)\n	local p = Instance.new(\"WedgePart\")\n	p.Archivable = false\n	p.Anchored = true\n	p.BottomSurface = 0\n	p.TopSurface = 0\n	p.formFactor = \"Custom\"\n	p.Size = Vector3.new(1,1,1)\n	p.Locked = true\n	p.Parent = parent or game.Workspace\n	return p\nend\n\nfunction util.create_triangle(a,b,c,parent,thickness)\n	thickness = thickness or 0.002\n	-- split triangle into two right angles on longest edge:\n	local len_AB = (b - a).magnitude\n	local len_BC = (c - b).magnitude\n	local len_CA = (a - c).magnitude\n\n	if (len_AB > len_BC) and (len_AB > len_CA) then\n		a,c = c,a\n		b,c = c,b\n	elseif (len_CA > len_AB) and (len_CA > len_BC) then\n		a,b = b,a\n		b,c = c,b\n	end\n\n	local dot = (a - b):Dot(c - b)\n	local split = b + (c-b).unit*dot/(c - b).magnitude\n\n	-- get triangle sizes:\n	local xA = thickness\n	local yA = (split - a).magnitude\n	local zA = (split - b).magnitude\n\n	local xB = thickness\n	local yB = yA\n	local zB = (split - c).magnitude\n\n	-- get unit directions:\n	local diry = (a - split).unit\n	local dirz = (c - split).unit\n	local dirx = diry:Cross(dirz).unit\n\n	-- get triangle centers:\n	local posA = split + diry*yA/2 - dirz*zA/2\n	local posB = split + diry*yB/2 + dirz*zB/2\n\n	-- place parts:\n	local partA = spawnTrianglePart(parent)\n	partA.Name = \"TrianglePart\"\n	partA.Size = Vector3.new(xA,yA,zA)\n	partA.CFrame = CFrame.new(posA.x,posA.y,posA.z, dirx.x,diry.x,dirz.x, dirx.y,diry.y,dirz.y, dirx.z,diry.z,dirz.z)\n\n	dirx = dirx * -1\n	dirz = dirz * -1\n\n	local partB = spawnTrianglePart(parent)\n	partB.Name = \"TrianglePart\"\n	partB.Size = Vector3.new(xB,yB,zB)\n	partB.CFrame = CFrame.new(posB.x,posB.y,posB.z, dirx.x,diry.x,dirz.x, dirx.y,diry.y,dirz.y, dirx.z,diry.z,dirz.z)\nend\n\nfunction util.rnd_color()\n	return Color3.new(\n		math.random(),\n		math.random(),\n		math.random()\n	)\nend\n\n\nlocal RED = Color3.new(1, 0, 0)\nlocal GREEN = Color3.new(0, 1, 0)\nlocal BLUE = Color3.new(0, 0, 1)\nfunction Point:create(parent, props)\n	if self.part and self.part.Parent then\n		return\n	end\n	\n	local p = Instance.new 'Part'\n	p.Name = tostring(self.id)\n	p.Archivable = false\n	p.Shape = Enum.PartType.Ball\n	p.FormFactor = Enum.FormFactor.Custom\n	p.BottomSurface = Enum.SurfaceType.Smooth\n	p.TopSurface = Enum.SurfaceType.Smooth\n	if self.ptype <= Point.MIDEXTERIOR then\n		p.Color = GREEN\n	elseif self.ptype >= Point.REFLEX then\n		p.Color = RED\n	else\n		p.Color = BLUE\n	end\n	p.Anchored = true\n	p.Size = Vector3.new(0.2, 0.2, 0.2)\n	p.Position = self.v3\n	self.part = p\n	if props then\n		self:set_props(props)\n	end\n	p.Parent = parent\n\n	return p\nend\nfunction Point:update(v3)\n	self.v3 = v3\n	if self.part then\n		self.part.Position = v3\n	end\n	for surface in next, self.surfaces do\n		local con = surface.c_conns[self]\n		if con then\n			con:update()\n		else\n			surface:update()\n		end\n	end\nend\nfunction Point:set_props(props)\n	local p = self.part\n	for k, v in next, props do\n		p[k] = v\n	end\nend\nfunction Point:destroy()\n	self.part:Destroy()\n	self.part = nil\nend\n\nfunction Surface:create_points(parent, color)\n	color = color or util.rnd_color()\n	local model = Instance.new 'Folder'\n	model.Archivable = false\n	for i, point in ipairs(self) do\n		point:create(model)\n		point.part.Name = point.part.Name .. ' ' .. tostring(i)\n	end\n	for at, action in next, self.c_conns do\n		at:create(model)\n	end\n	self.points = model\n	model.Name = 'Points ' .. self.id\n	model.Parent = parent\n	CS:AddTag(model, 'Polaris-Mesh')\n	return model\nend\n\nfunction Surface:create_surface(parent, color)\n	if color then\n		self.color = color\n	end\n\n	color = color or util.rnd_color()\n\n	if not self:is_convex() then\n		color = Color3.new(1, 0, 0)\n	end\n\n	local model = Instance.new 'Folder'\n	model.Archivable = false\n\n	local a, b, c = self[1].v3, self[2].v3, self[3].v3\n	util.create_triangle(a, b, c, model, self.thickness)\n\n	local center = a + b + c\n	for i = 4, #self do\n		b = c\n		c = self[i].v3\n		center = center + c\n		util.create_triangle(a, b, c, model, self.thickness)\n	end\n	center = center / #self\n	util.create_line(center, self.normal * 1, model)\n\n	for i, p in ipairs(model:GetChildren()) do\n		p.Color = color\n		p.Transparency = 0.5\n	end\n	self.surface = model\n	model.Name = 'Surface ' .. self.id\n	model.Parent = parent\n	CS:AddTag(model, 'Polaris-Surface')\n	return model\nend\n\nfunction Surface:create_connections(parent, color)\n	for i, con in ipairs(self.connections) do\n		if con.fromID == self.id then\n			con:create_bounds(parent, color)\n		end\n	end\nend\n\nfunction Surface:destroy_points()\n	for i, p in ipairs(self) do\n		p:destroy()\n	end\n	self.points:Destroy()\n	self.points = nil\nend\n\nfunction Surface:destroy_surface()\n	self.surface:Destroy()\n	self.surface = nil\nend\n\nfunction Surface:update()\n	-- TODO: runs checks\n	if not self.surface then\n		return\n	end\n\n	local example = self.surface:GetChildren()[1]\n	local color = self.color\n	if not self:is_convex() then\n		color = Color3.new(1, 0, 0)\n	end\n	local trans = example.Transparency\n	local parent = self.surface.Parent\n	self:destroy_surface()\n	self:create_surface(parent)\n	self:set_props({\n		Color = color;\n		Transparency = trans;\n	})\nend\n\nfunction Surface:set_props(props)\n	for i, child in ipairs(self.surface:GetChildren()) do\n		for k, v in next, props do\n			child[k] = v\n		end\n	end\nend\n\nfunction Connection:create_bounds(parent, color)\n	local sf = self.from\n	local st = self.to\n	local a = sf:get_p(self.i1, self.t1)\n	local b = st:get_p(self.j1, self.u1)\n	local c = sf:get_p(self.i2, self.t2)\n	local d = st:get_p(self.j2, self.u2)\n\n	local model = Instance.new 'Model'\n	model.Archivable = false\n	model.Name = 'Connection ' .. self.action .. ':' .. self.fromID .. '->' .. self.toID\n\n	util.create_line(a, b - a, model)\n	util.create_triangle(a, b, c, model)\n	util.create_triangle(b, c, d, model)\n	util.create_line(c, d - c, model)\n\n	for i, child in ipairs(model:GetChildren()) do\n		child.Color = color\n		child.Transparency = 0.7\n	end\n	\n	model.Parent = parent\n\n	return model\nend\n\nfunction Mesh:create_surfaces(root, mesh_id, color_s)\n	local folder = Instance.new 'Folder'\n	folder.Archivable = false\n	folder.Name = 'Mesh ' .. mesh_id\n	for i, surface in ipairs(self.surfaces) do\n		surface:create_surface(folder, color_s)\n		surface:create_points(folder, color_s)\n	end\n\n	for i, c_conn in ipairs(self.c_conns) do\n		c_conn:create(folder)\n	end\n\n	-- create all connections\n	-- for i, connection in ipairs(self.connections) do\n	-- 	local c = connection:create_bounds(folder, color_c)\n	-- 	CS:AddTag(c, 'Polaris-Mesh')\n	-- end\n\n	-- create all reflex connections\n\n\n	CS:AddTag(folder, 'Polaris-Mesh')\n	folder.Parent = root\n	self.folder = folder\n	return folder\nend\n\nreturn true"
local descendantModuleScript30 = Instance.new("ModuleScript", descendantModuleScript29)
descendantModuleScript30.Name = "save_data"
descendantModuleScript30.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\n\n\nlocal F = e.format\nlocal util = e.util\n\nutil.d2b = e.ieee754.double2bin;\n\nlocal function a(to, str)\n	to[#to + 1] = str\n	if to.size then\n		to.size = to.size + #str\n	end\nend\n\nfunction util.i2b(x)\n	local bytes = {nil, nil, nil, nil}\n	for i = 1, 4 do\n		local byte = x % 256\n		x = (x - byte) / 256\n		bytes[i] = byte\n	end\n\n\n	return string.char(table.unpack(bytes))\n\nend\n\nfunction util.i642b(x)\n	local bytes = {nil, nil, nil, nil, nil, nil, nil, nil}\n	for i = 1, 8 do\n		local byte = x % 256\n		x = (x - byte) / 256\n		bytes[i] = byte\n	end\n\n\n	return string.char(table.unpack(bytes))\n\nend\n\nfunction util.v2b(v)\n	local s = table.concat {\n		util.d2b(v.X),\n		util.d2b(v.Y),\n		util.d2b(v.Z)\n	}\n\n	return s\nend\n\nfunction util.s2b(s)\n	return util.i2b(#s) .. s\nend\n\nfunction util.a2b(v)\n	local ty = type(v)\n	if ty == 'string' then\n		return string.char(0) .. util.s2b(v)\n	elseif ty == 'number' then\n		return string.char(1) .. util.d2b(v)\n	end\nend\n\nfunction util.encode(value)\n	e:load 'zero_encoding'\n	return util.encode_zeros(e.LibDeflate:CompressDeflate(value, {level = 9}))\nend\n\nfunction F.String:save(data)\n	return a(data, util.s2b(self))\nend\nfunction F.Bool:save(data)\n	return a(data, self\n		and string.char(1)\n		or string.char(0))\nend\nfunction F.V3:save(data)\n	return a(data, util.v2b(self))\nend\n\nfunction F.Byte:save(data)\n	return a(data, string.char(self))\nend\n\nfunction F.Double:save(data)\n	return a(data, util.d2b(self))\nend\n\nfunction F.Int:save(data)\n	return a(data, util.i2b(self))\nend\n\nfunction F.Int64:save(data)\n	return a(data, util.i642b(self))\nend\n\nfunction F.Any:save(data)\n	return a(data, util.a2b(self))\nend\n\nfunction util.save(data, obj, format, context)\n	if not format then\n		return\n	end\n\n	-- custom types have a \"format\" property\n	format = format.format or format\n\n\n\n	if format.type then\n		if format.type == 'compat' then\n			util.save(data, obj, format.func(context), context)\n		elseif format.type == 'ref' then\n			a(data, util.i2b(obj.id))\n		elseif format.type == 'konst' then\n			if format.is_serialized then\n				util.save(data, format.value, format.v_format, context)\n			end\n		elseif format.type == 'save' then\n			util.save(data, obj, format.v_format, context)\n			if format.v_format.type == 'konst' then\n				context[format.name] = format.v_format.value\n			else\n				context[format.name] = obj\n			end\n		elseif format.type == 'enable_if' then\n			util.save(data, obj, format.v_format, context)\n		elseif format.type == 'union' then\n			for j, v_format in ipairs(format) do\n				util.save(data, obj, v_format, context)\n			end\n		elseif format.type == 'struct' then\n			for j, field in ipairs(format.fields) do\n				local k, v = next(field)\n\n				util.save(data, obj[k], v, context)\n			end\n		elseif format.type == 'array' then\n			local v_format = format.v_format\n			for i = 1, format.len do\n				util.save(data, obj[i], v_format, context)\n			end\n		else\n			local i, n = #data + 1, 0\n			data[i] = ''\n			if format.type == 'list' then\n				local v_format = format.v_format\n				n = #obj\n				for i, v in ipairs(obj) do\n					util.save(data, v, v_format, context)\n				end\n			elseif format.type == 'map' then\n				local k_format = format.k_format\n				local v_format = format.v_format\n				for k, v in next, obj do\n					n = n + 1\n					util.save(data, k, k_format, context)\n					util.save(data, v, v_format, context)\n				end\n			else\n				print('unknown format type:', format.type)\n			end\n			data[i] = util.i2b(n)\n		end\n	end\n\n	if format.save then\n\n\n		format.save(obj, data, context)\n	end\n\n\nend\n\nreturn true"
local descendantModuleScript31 = Instance.new("ModuleScript", descendantModuleScript30)
descendantModuleScript31.Name = "util"
descendantModuleScript31.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\nlocal util = {}\n\nlocal prec = 1e-3\nutil.prec = prec\n\nlocal prec2 = prec^2\n\n-- compute epsilon real quick\nlocal e = 1\nwhile 1 + e ~= 1 do\n	e = e * 0.5\nend\nutil.e = e\n\n\n\nfunction util.mod1_dec(x, m)\n	return (x - 2) % m + 1\nend\n\nfunction util.mod1_inc(x, m)\n	return x % m + 1\nend\n\nfunction util.bind(f, obj)\n	return function(...)\n		return f(obj, ...)\n	end\nend\n\nfunction util.union_k(...)\n	local r = {}\n	for i, t in ipairs{...} do\n		for k, v in next, t do\n			r[k] = v\n		end\n	end\n	return r\nend\n\nfunction util.union_i(...)\n	local r = {}\n	for j, t in ipairs{...} do\n		for i, v in ipairs(t) do\n			r[#r + 1] = v\n		end\n	end\n	return r\nend\n\nfunction util.validate_bool(txt)\n	txt = txt:lower()\n	if txt == 'true' or txt == 't' then\n		return true\n	elseif txt == 'false' or txt == 'f' then\n		return false\n	end\nend\n\nfunction util.get_trace(msg)\n	return msg .. '; ' .. debug.traceback()\nend\n\nfunction util.pcall(f, ...)\n	return xpcall(f, util.get_trace, ...)\nend\n\n\n\nreturn util"
local descendantModuleScript32 = Instance.new("ModuleScript", descendantModuleScript31)
descendantModuleScript32.Name = "zero_encoding"
descendantModuleScript32.Source = "\n-- Polaris-Nav, advanced pathfinding as a library and service\n-- Copyright (C) 2021 Tyler R. Herman-Hoyer\n-- tyler@hoyerz.com\n--\n-- This program is free software; you can redistribute it and/or\n-- modify it under the terms of the GNU Lesser General Public\n-- License as published by the Free Software Foundation; either\n-- version 3 of the License, or (at your option) any later version.\n--\n-- This program is distributed in the hope that it will be useful,\n-- but WITHOUT ANY WARRANTY; without even the implied warranty of\n-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-- Lesser General Public License for more details.\n--\n-- You should have received a copy of the GNU General Public License\n-- along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\n\nlocal e = require(script.Parent)\n\n\nlocal util = e.util\n\nlocal special = string.char(255)\nfunction util.encode_zeros(value)\n	local data = {}\n	local i = 1\n	local n = #value\n	while i <= n do\n		local b = value:byte(i)\n		if b == 0 then\n			local m = 1\n			while i < n and m < 254 do\n				if value:byte(i + 1) == 0 then\n					m = m + 1\n					i = i + 1\n				else\n					break\n				end\n			end\n			data[#data + 1] = special\n			data[#data + 1] = string.char(m)\n		elseif b == 255 then\n			data[#data + 1] = special\n			data[#data + 1] = special\n		else\n			data[#data + 1] = string.char(b)\n		end\n		i = i + 1\n	end\n	return table.concat(data)\nend\n\nlocal null = string.char(0)\nfunction util.decode_zeros(value)\n	local data = {}\n	local i = 1\n	local n = #value\n	while i <= n do\n		local b = value:byte(i)\n		if b == 255 then\n			i = i + 1\n			b = value:byte(i)\n			if b == 255 then\n				data[#data + 1] = special\n			else\n				for j = 1, b do\n					data[#data + 1] = null\n				end\n			end\n		else\n			data[#data + 1] = string.char(b)\n		end\n		i = i + 1\n	end\n	return table.concat(data)\nend\n\nreturn true"
